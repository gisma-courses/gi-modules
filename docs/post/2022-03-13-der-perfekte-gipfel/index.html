<!DOCTYPE html>
<html lang="en-us^">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <meta property="og:site_name" content="gi-modules">
    <meta property="og:type" content="article">

    
    <meta property="og:image" content="https://gisma-courses.github.io/gi-modules///assets/images/face-sp.jpg">
    <meta property="twitter:image" content="https://gisma-courses.github.io/gi-modules///assets/images/face-sp.jpg" />
    

    
    <meta name="title" content="Der perfekte Gipfel" />
    <meta property="og:title" content="Der perfekte Gipfel" />
    <meta property="twitter:title" content="Der perfekte Gipfel" />
    

    
    <meta name="description" content="">
    <meta property="og:description" content="" />
    <meta property="twitter:description" content="" />
    

    
    <meta property="twitter:card" content="summary" />
    
    
    
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-fQybjgWLrvvRgtW6bFlB7jaZrFsaBXjsOMm/tB9LTS58ONXgqbR9W8oWht/amnpF" crossorigin="anonymous"></script>
<link rel="stylesheet" href="/gi-modules/css/hugo-cite.css" />


<script src="https://gisma-courses.github.io/gi-modules/js/highlight.min.js"></script>
 
<script>hljs.highlightAll();</script>

    <meta name="keyword"  content="gisma">
    <link rel="shortcut icon" href="/gi-modules/img/favicon.ico">

    <title>Der perfekte Gipfel-your title</title>

    <link rel="canonical" href="/gi-modules/gi-modules/post/2022-03-13-der-perfekte-gipfel/">
    

  <script src="https://unpkg.com/boxicons@2.0.9/dist/boxicons.js"></script>
    
    <link href="https://gisma-courses.github.io/gi-modules/css/boxes.css" rel="stylesheet">

    <link rel="stylesheet" href="/gi-modules/css/iDisqus.min.css"/>

    
    <link rel="stylesheet" href="/gi-modules/css/bootstrap.min.css">

    
    <link rel="stylesheet" href="/gi-modules/css/hugo-theme-cleanwhite.min.css">

    
    <link rel="stylesheet" href="/gi-modules/css/zanshang.css">

    
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css" rel="stylesheet" type="text/css">

    
     
    

    
    

<link href='//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/idea.min.css' rel='stylesheet' type='text/css' />



    
    <script src="/gi-modules/js/jquery.min.js"></script>

    
    <script src="/gi-modules/js/bootstrap.min.js"></script>

    
    <script src="/gi-modules/js/hux-blog.min.js"></script>

    
    

</head>




<nav class="navbar navbar-default navbar-custom navbar-fixed-top">

    <div class="container-fluid">
        
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/gi-modules/"> HOME </a>
        </div>

        
        
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                   
                    
                        
                        <li>
                            <a href="/gi-modules/categories/agis">agis</a>
                        </li>
                        
                        <li>
                            <a href="/gi-modules/categories/bgis">bgis</a>
                        </li>
                        
                        <li>
                            <a href="/gi-modules/categories/giswerk">giswerk</a>
                        </li>
                        
                        <li>
                            <a href="/gi-modules/categories/rs-spatial">rs-spatial</a>
                        </li>
                        
                        <li>
                            <a href="/gi-modules/categories/xtra">xtra</a>
                        </li>
                        
                    
                    
		    
                        <li><a href="/gi-modules/top/archive/">CONTENT</a></li>
                    

                    
                </ul>
            </div>
        </div>
        
    </div>
    
</nav>
<script>
    
    
    
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        
            $navbar.className = " ";
            
            setTimeout(function(){
                
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>





 
  <script>
  $(document).ready(function () {
    window.initializeCodeFolding("show" === "hide");
  });
  </script>
  <script src="/gi-modules/js/codefolding.js"></script>


<style type="text/css">
    header.intro-header {
        background-image: url('/gi-modules/assets/images/face-sp.jpg');
  max-height: 350px
    }
</style>

<header class="intro-header" >

    <div class="container">
        <div class="row">
            <div class="col-lg-0 col-lg-offset-0 col-md-0 col-md-offset-0">
                <div class="post-heading">
                   
                    <h1>Der perfekte Gipfel</h1>
                   
            
                            
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>





<article>
    <div class="container">
        <div class="row">

            
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                
                

<div id="TOC">

</div>

<div id="the-perfect-peak" class="section level1">
<h1>The perfect Peak</h1>
<p>Das Beispiel des perfekten Gipfels wurde nicht nur aus persönlichem Interesse gewählt, sondern auch weil es ein gelungenes Beispiel für die nahezu beliebige Komplexität, der bei der Beantwortung einer scheinbar einfachen räumlichen Frage zu berücksichtigenden Faktoren, bietet. Gleichzeitig ist es keinen wissenschaftlichen Paradigmen zugeordnet, was die inhaltliche und wissenschaftliche Beschäftigung mit der Thematik deutlich vereinfacht, da so auf die Methodik fokussiert werden kann. Gerade dieser pragmatische Ansatz soll die seltene Kompetenz entwickeln helfen <strong>sowohl</strong> die iterative (und häufig auch rekursive) Entwicklung wissenschaftlicher Fragestellungen zu trainieren <strong>als auch</strong> die notwendigen Fähigkeiten vermitteln die konzeptionellen Lösungen auch eigenständig umzusetzen zu können.</p>
<p>Und ganz wichtig- es geht immer besser. Trotz der Methodenlastigkeit geht es hier nicht um “<em>gute Programmierung</em>” sondern darum die Fragen die einem so in den Sinn kommen beantworten zu können und nicht umgekehrt die Antwort den Möglichkeiten zu fragen anzupassen.</p>
<p>Ungeachtet dessen sind alle eingeladen klarer und eleganter zu fragen und zu antworten!</p>
<div id="einleitung-und-hintergrund" class="section level2">
<h2>Einleitung und Hintergrund</h2>
<p>Der perfekte Gipfel kann - folgt man Christian Rauch im Panorama Artikel 2/2012, S. 112 [(<a href="http://www.alpenverein.de/dav-services/panorama-magazin/dominanz-prominenz-eigenstaendigkeit-eines-berges_aid_11186.html" class="uri">http://www.alpenverein.de/dav-services/panorama-magazin/dominanz-prominenz-eigenstaendigkeit-eines-berges_aid_11186.html</a>)], unter Vernachlässigung ästhetischer oder kultureller Einflüsse, mit dem Eigenständigkeitswert berechnet werden. Unsere rein praktisch ausgerichtete Problemstellung lautet daher:</p>
<p><strong>Berechne für jeden Gipfel den Eigenständigkeitswert.</strong></p>
<p>Zunächst gilt es den Artikel von Rauch zu analysieren und der teilweise prosaischen Betrachtungsweise die Begriffe und Parameter zu entnehmen, die für die Berechnung der Eigenständigkeit notwendig sind. Folgt man wie der Autor Rauch der Definition von Bernhard [( Bernhard, W., Eigenständigkeit von Gipfeln, <a href="http://www.thehighrisepages.de/bergtouren/na_orogr.htm#BK" class="uri">http://www.thehighrisepages.de/bergtouren/na_orogr.htm#BK</a> , Letzter Zugriff: 1.5.2012)] erscheint dies zunächst einfach. So schreibt Bernhard:</p>
<p><em>“Um Gipfel auf ihre geografische, genauer: orografische Bedeutung hin zu betrachten, nimmt der Autor eine Berechnung der Eigenständigkeit (E) nach Höhe, Dominanz und relativer Prominenz vor. Diese drei Kennzahlen dürften die Bedeutung eines Berges am ehesten erfassen. Die Prominenz gibt an, wie tief ein Gipfel herausgearbeitet ist, die Dominanz, wie weit dieser von einem höheren entfernt ist, und die Höhe, wie weit er selbst andere zu überragen vermag. Diese drei Größen sind messbar und damit objektiv und einheitlich, einfach zu erheben, und nahtlos anwendbar für die gesamte Erde, vom Achttausender bis zum Küstenhügel”.</em></p>
<p>Aus wissenschaftshistorischer und geographischer Sicht greifen die Betrachtungen von Bernhard gewiss zu kurz. Es gibt eine lange fachübergreifende Diskussion zur kognitiv-ästhetischen, orographischen, morphologischen und morphometrischen Bestimmung von Geländeformen im Relief. Dies gilt um so mehr für die Bestimmung der Begriffe Berge, Scharten, Gipfel etc.. Eine für unsere Zwecke guten Überblick bietet Rasemann (2004:8-10) [(Rasemann, S. (2004), Geomorphometrische Struktur eines mesoskaligen alpinen Geosystems, Asgard-Verlag, St. Augustin, Bonner Geographische Abhandlungen, Heft Nr. 111, URL: <a href="http://hss.ulb.uni-bonn.de/2003/0211/0211.htm" class="uri">http://hss.ulb.uni-bonn.de/2003/0211/0211.htm</a>)]. Für eine konzeptionelle Analyse zur Umsetzung der Bernhard’schen Berechnung müssen diese kontroversen Definitionen (zunächst) nicht näher in Betracht gezogen werden. Wir halten uns an Bernhard’s Postulat, dass die Berechnung objektiv und universell anwendbar sei. Jedoch wird sich zeigen dass nicht nur die Berücksichtigung der ästhetischen und kognitiven Aspekte der von Rauch geführten Diskussion sondern auch die <em>objektive</em> Klassifikation von Gipfeln, Scharten etc. eine deutlich weitergehende Auseinandersetzung mit diesem Thema erforderlich machen.</p>
<p>Letztlich wird in der Spannweite von dem Ansatz “<em>Gipfelkoordinaten und Namen werden als als gegeben betrachtet</em>” bis hin zu Konzept “<em>Gipfel werden ausschließlich aus der Geländeform der verfügbaren Daten bestimmt</em>” eine Definition notwendig werden. Diese Festlegung wird im wesentlichen von ihrer Zweckmäßigkeit zur Beantwortung der Fragestellung abhängen.</p>
</div>
<div id="konzeption" class="section level2">
<h2>Konzeption</h2>
<p>Die Fragestellung ist im Detail einiges komplexer als der erste Eindruck es vermuten lässt. Daher ist es sinnvoll zunächst nur die scheinbar einfachste, weil objektiv berechenbare Vorgehensweise zur Bestimmung der Eigenständigkeit eines Gipfels konzeptionell umzusetzen.</p>
<div id="definitionen-und-annahmen" class="section level3">
<h3>Definitionen und Annahmen</h3>
<p>Analysiert man den Text bzw. die Formel zur Berechnung der Eigenständigkeit (E) verwendet der Autor folgende Größen:</p>
<pre><code>h = Höhe                        (absolute Höhe des betrachteten Gipfels)
d = Dominanz                    (horizontale Distanz zum nächsten, höheren Geländepunkt)
p = Prominenz/Schartendifferenz (Höhendifferenz zur tiefsten Scharte im Verbindungsgrat zum nächsthöheren Gipfel)</code></pre>
<p>Diese Begriffe zureichend zu diskutieren kann in diesem Zusammenhang nicht in erschöpfender Weise geschehen. Dennoch müssen einige Überlegungen getätigt werden:</p>
<pre><code>- Auf welcher Datengrundlage (räumliche Auflösung, Datenqualität) sollen die obigen Größen berechnet werden?
- Wie sollen Gipfel identifiziert bzw. definiert werden? 
- Wie kann auf dieser Grundlage die Schartendifferenz definiert werden? </code></pre>
<p>Es werden folgende Annahmen getätigt:</p>
<ul>
<li><p>Zur räumlichen, quasi-kontinuierlichen Bestimmung von Höhenwerten sind rastermodell-basierte Geländemodelle geeignet. Dank der mittlerweile guten Verfügbarkeit in den unterschiedlichsten räumlichen Auflösungen sind rasterbasierte digitale Geländemodells (DGM) für eine automatisierte Bearbeitung vorteilhaft. Generell kann die Berechnung der Eigenständigkeit mit allen verfügbaren Höhenmodelldaten durchgeführt werden. Die Berechnung erfolgt mit frei verfügbaren DGM-Daten. Es bieten sich vor allem die ASTER GDEM[(Aster: <a href="http://www.jspacesystems.or.jp/ersdac/GDEM/E/" class="uri">http://www.jspacesystems.or.jp/ersdac/GDEM/E/</a>)] oder SRTM [(SRTM: <a href="http://srtm.csi.cgiar.org/" class="uri">http://srtm.csi.cgiar.org/</a>)] Datensätze an.</p></li>
<li><p>Gipfel sind:</p>
<ul>
<li>die Maximalwerte in einer definierten räumlichen Umgebung ** und/oder**</li>
<li>die Zentroidpunkte einer morphometrisch abgeleiteten Formstruktur <strong>und/oder</strong></li>
<li>Namenenskodierte Orte</li>
</ul></li>
<li><p>Die maximale Schartendifferenz ist die Differenzhöhe zum niedrigsten Punkt der höchstmöglichen Verbindung vom betrachteten Gipfel zum nächsten höheren Gipfel.</p></li>
</ul>
</div>
<div id="mögliche-algorithmen" class="section level3">
<h3>Mögliche Algorithmen</h3>
<div id="datenvorbereitung" class="section level4">
<h4>Datenvorbereitung</h4>
<ul>
<li>DGM Daten einlesen (Formate und Umwandlung sind abhängig von der verwendeten Quelle)</li>
<li>Ergebnistabelle mit den folgenden Attributen anlegen</li>
</ul>
<p>^ Gipfelkennung ^ Hochwert ^ Rechtswert ^ Dominanzwert ^ Prominenzwert ^ Eigenständigkeitswert ^
| ID | | | | | |</p>
</div>
<div id="gipfel-identifizieren" class="section level4">
<h4>Gipfel identifizieren</h4>
<p>Zur Identifikation von Gipfel stehen sehr unterschiedliche Möglichkeiten zur Verfügung. Prinzipiell lassen sie sich in zwei Kategorien unterscheiden. Sie können aus <strong>(1)</strong> den Daten selbst berechnet werden oder man kann sie** (2)** aus externen Quellen verfügbar machen. Daraus leiten sich die drei nachfolgenden Ideen ab.</p>
<ul>
<li>Gipfel nach der morphometrischen Kriterien bestimmen
<ul>
<li>Zentrale Koordinate der Gipfelposition (Zentroid der Fläche oder Zentroidkoordinate des Pixel) der morphometrischen Gipfelbestimmung extrahieren GipfelID zuweisen</li>
<li>Gipfel als lokales Höhenmaximun bestimmen (Moore-Nachbarschaft), Zentroidkoordinate des Pixel extrahieren GipfelID zuweisen</li>
</ul></li>
<li>Gipfelnamen aus Tabellen und Karten extrahieren
<ul>
<li>Namen von Gipfeln geokodieren bzw. Namen und Koordinaten von Gipfeln verwenden und räumlich möglichst am korrespondierender Position im DGM reverses Geokodieren verorten.</li>
</ul></li>
</ul>
<p>GipfelID, Koordinaten und Höhenwert → Tabelle schreiben</p>
</div>
<div id="dominanz-berechnen" class="section level4">
<h4>Dominanz berechnen</h4>
<p>Die folgenden Schritte müssen für jeden Berg einzeln durchgeführt werden.</p>
<ul>
<li>Für jede GipfelID ein Raster der euklidischen Distanz zu den größeren Höhenwerten berechnen</li>
<li>Minimalen Entfernungswert extrahieren und der Ergebnistabelle hinzufügen</li>
</ul>
<p>Dominanz → Tabelle schreiben
#### Prominenz berechnen</p>
<p>Zur Berechnung der Prominenz stehen ebenfalls unterschiedliche Möglichkeiten zur Verfügung. Hier werden zwei Ideen vorgestellt. <strong>(1)</strong> Mit Hilfe eines statischen “Flutmodells” werden jeweils 2 Gipfel miteinander verbunden und <strong>(2)</strong> es wird eine Identifikation der die Gipfel verbindenden Grate als morphologischer Struktur durchgeführt. Im einzelnen leiten sich die beiden nachfolgenden Ideen ab:</p>
<ul>
<li>Flutmodell
<ul>
<li>Schrittweise Flächen zulassen, die niedrigere Höhenwerte haben als der Gipfel, bis die Schnittfläche Pixel nur zwei Gipfel enthält</li>
<li>Den Mindestwert dieses Rasters als Schartenhöhe extrahieren = Prominenz → Tabelle schreiben</li>
</ul></li>
<li>Gratmodell
<ul>
<li>von jedem Gipfel alle Grate zu höheren Gipfeln identifizieren</li>
<li>Jeweils den niedrigsten Höhenwert in eine Liste schreiben</li>
<li>maximaler Höhenwert dieser Liste = größte Schartenhöhe = Prominenz → Tabelle schreiben</li>
</ul></li>
</ul>
<p>Prominenz → Tabelle schreiben</p>
</div>
<div id="eigenständigkeit-berechnen" class="section level4">
<h4>Eigenständigkeit berechnen</h4>
<p>Die Eigenständigkeit berechnet sich nach Bernhard [(#2)] wie folgt:</p>
<pre><code>Für d &lt;100.000m:

E = -((log2  (h / 8848) + log2 (d / 100000) + log2(p / h)) / 3) 


Für d &gt; 100.000m:

E = -((log2 (h / 8848) + log2(p / h)) / 3)</code></pre>
<p>Eigenständigkeit → Tabelle schreiben</p>
</div>
</div>
<div id="umsetzung-der-konzepte-mit-r-saga-grass" class="section level3">
<h3>Umsetzung der Konzepte mit R, SAGA, GRASS</h3>
<p>Wie sich herausstellen wird gibt es gute Gründe ein (willkürliches) Mix an (GIS-)Software zu nutzen. Die Implementierung ist recht umfangreich dokumentiert und kommentiert. Übergeordnet geht es jedoch um die folgenden Kompetenzen:</p>
<ul>
<li>Erwerb struktureller Kompetenzen zur technische Umsetzung
<ul>
<li>Es soll exemplarisch gezeigt werden wie unterschiedlichste Bibliotheken verwendet werden können</li>
<li>Es soll gezeigt werden dass konzeptionelle Vorstellungen immer überprüfbar sein müssen und natürlich auch evaluiert gehören</li>
<li>Es soll ausführlich kommentiert und erläutert werden (inkl. wissenschaftlicher und technischer Verweise)</li>
</ul></li>
<li>Ganz wichtig ist die (zwar nur minimale) aber sehr wichtige fachliche Diskussion und Definition der Begriffe
<ul>
<li>Geländeformen, Gebirge</li>
<li>Regeln zur ästhetischen Klassifikation</li>
</ul></li>
</ul>
</div>
<div id="implementierung" class="section level3">
<h3>Implementierung</h3>
<p>Für die nachfolgenden Arbeitsschritte müssen die freien Softwarepakete R, GRASS und SAGA installiert sein. Das Script ist unter Ubuntu 11.10 mit der R Version 2.15.0 (64-bit), GRASS 6.4.2 und SAGA Version: 2.0.8 getestet. Alle aufgerufenen Bibliotheken sind aktualisiert.</p>
<div id="vorbereitung-der-projekt-arbeitsumgebung" class="section level4">
<h4>Vorbereitung der Projekt-Arbeitsumgebung</h4>
<p>Zunächst müssen für R die GRASS und SAGA Schnittstellenpakete und einige R-packages installiert werden. Auf der R-Konsole z.B.</p>
<pre class="r"><code>install.packages(c(&quot;RSAGA&quot;, &quot;spgrass6&quot;, &quot;rgdal&quot;, &quot;maptools&quot;, &quot;raster&quot;, &quot;sp&quot;))</code></pre>
<p>Dann geht es mit dem Import der packages und dem Festlegen der Arbeitspfade etc. weiter:</p>
<pre><code>##Laden der grundlegenden libraries für die Verarbeitung räumlicher Daten
#-------.
library(sp)         # R spatial package
library(rgdal)      # R GDAL interface
library(maptools)   # R maptools package
library(spgrass6)   # R GRASS interface
library(RSAGA)      # R SAGA interface
library(raster)     # R raster package


## Arbeitsumgebung setzten
#-------.

# Arbeitsverzeichnis R
#-------.
setwd(&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA&quot;)
Rhome=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA&quot;


# Pfade und SETUP für GRASS 
#-------.

initGRASS(gisBase=&quot;/usr/lib/grass64&quot;, home=tempdir(), 
          gisDbase=&quot;/home/creu/workspace/grassprojects&quot;, 
          location=&quot;GIPFEL&quot;, mapset=&quot;SRTM&quot;,
          override=TRUE) 

# INFOS zum MAPSET
gmeta6()
str(gmeta6())

# Pfade und SETUP für SAGA 
#-------.

rsaga.env(workspace=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA&quot;)
myenv=rsaga.env(workspace=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA&quot;,path=&quot;/usr/local/bin&quot;,modules=&quot;/usr/local/lib/saga&quot;)
SHome=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA&quot;</code></pre>
</div>
<div id="daten" class="section level4">
<h4>Daten</h4>
<p>Die Pfade des <strong>persönlichen Arbeitsverzeichnisses</strong> sind natürlich wie
immer anzupassen. Zunächst gilt es sich die Daten zu besorgen und für eine Berechnung verfügbar zu machen. Für das aktuelle Beispiel wurden SRTM Geländemodelldaten verwendet. Das Skript zeigt mehrere Möglichkeiten auf diese einzulesen. Ebenso wird beschrieben wie die Gipfelliste (teil automatisiert geladen und eingelesen werden kann.</p>
<pre><code>
#-------.
#   Daten Import/Export
#-------.
#  Es werden einige Möglichkeiten aufgezeigt verschiedene Daten für die weitere Verarbeitung verfügbar zumachen.
# 1) Datenimport aus XYZ Daten des Landesvermessungsamtes
# 2) Datenimport aus SRTM GEOTIFF Binärdaten 
#    jeweils in SAGA, GRASS, R 
#-------.
# Anmerkungen:
# Für alle weiteren Bedürfnisse muss leider auf die Modulbeschreibungen etc. verwiesen werden. 
# GEO-Datenhandling ist dank GDAL/OGR VIEL leichter geworden gehört aber immer noch mit zum Lästigsten überhaupt  
#-------.



## Import nach GRASS von XYZ ASCII Daten mit SPACE &quot; &quot; getrennt und Punkt &quot;.&quot; als Dezimaltrennzeichen Achtung x=RW y=HW Z=h GAUSSKRüger DHDN 3 (so kommts vom LVA)
#execGRASS(&quot;r.in.xyz&quot;, flags=c(&quot;overwrite&quot;), input=&quot;/home/creu/workspace//grassprojects/GIPFEL/SRTM/DGM10_3436996_5583209.xyz&quot;, output=&quot;DGM_1&quot;,  fs=&quot; &quot;, y=as.integer(2),x=as.integer(1), z=as.integer(3),pth=as.integer(1), zscale=1.0,percent=as.integer(100))

## Import nach SAGA von XYZ ASCII Daten mit SPACE &quot; &quot; getrennt und Punkt &quot;.&quot; als Dezimaltrennzeichen Achtung x=RW y=HW Z=h GAUSSKRüger DHDN 3 (so kommts vom LVA)
#rsaga.geoprocessor(&quot;io_grid&quot;,6,env=myenv,list(FILENAME=&quot;DGM10_3436996_5583209.xyz&quot;, GRID=&quot;DG&quot;, CELLSIZE=&quot;10&quot;,SEPARATOR=&quot;space&quot;))

## Import nach R von XYZ ASCII Daten mit SPACE &quot; &quot; getrennt und Punkt &quot;.&quot; als Dezimaltrennzeichen Achtung kein header!
#dor &lt;- read.table(&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/DGM10_3436996_5583209.xyz&quot;, header=F)

## Import nach GRASS von GDAL GeoTIFF Daten Achtung dise müssen zuvor projiziert sein
execGRASS(&quot;r.in.gdal&quot;, flags=c(&quot;overwrite&quot;), input=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/srtm_39_03/srtm_39_03utm.tif&quot;, output=&quot;DGM&quot;)


## Export von GRASS als GEOTIFF 
## (Workaround ist z.B. für SAGA statt direktem Auschreiben notwendig wegen möglicher NAN Fehler in der GDAL Bib)
## Wird hier gemacht6 weils unten je nach Algorithmus mit SAGA Formaten weitergeht 
execGRASS(&quot;r.out.gdal&quot;, flags=c(&quot;c&quot;),input=&quot;DGM&quot;, type=&quot;Float32&quot;, output=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/DGM.tif&quot;)
           
## Import SAGA ACHTUNG Bennennung muss GRIDS und FILES heissen NICHT GRID/FILENAME
rsaga.geoprocessor(&quot;io_gdal&quot;,0,env=myenv,list(GRIDS=&quot;DGM.sgrd&quot; , FILES=&quot;DGM.tif&quot;))

if (gipfelliste==T){
## Tourenwelt Bergliste enthält den wohl aktuellsten Datensatz zu Gipfeln 
## Der wird im folgenden geladen eingelesen reprojiziert und auf das Untersuchunggebiet ausgeschitten
## benötigt Internet
## TODO &quot;shapes_grid&quot;,10 benötigt noch die von Hand eingetragfenen Parameter des Grids 
## Die Projektion ist auf UTM festverdrahtet muss also für jede U-Gebiet angepasst werden  
## Die Bergliste muss noch geparst werden da so nur die Koordinaten + Namen (gpx import) oder alles nur keine namen Cvs import
## verfügbar sind (warum auch immer) ALTERNATIVE reverse Geocoding
## Natürlich könnte man auch ein bisschen tricksen. 
## 1) konvertieren als CVS dann austausch der HTM Zeichen von hand oder mit kommandozeile
## 2) Import des ganzen als gpx alles wegschmeisen bis auf koordinaten und Namen
## 3) Merge von beiden
# download der datei
system(&quot;wget http://www.tourenwelt.info/commons/download/bergliste-komplett.kmz.php&quot;)
# umbenenen da gunzip nur .gz verarbeitet
system(&quot;mv /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.kmz.php /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.gz&quot;)
# entzippen da es sich um kmz handelt pgsbabel aber nur kml kann
system(&quot;gunzip -f /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.gz&quot;)
#anhängen der  kml endung
system(&quot;mv -f /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.kml&quot;)
# export als gpx datei
system(&quot;gpsbabel -i kml -f /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.kml -o gpx -F /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.gpx&quot;)
#export als csv datei
system(&quot;gpsbabel -i kml -f /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.kml -o unicsv -F /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.csv&quot;)
}
</code></pre>
</div>
<div id="gipfelerkennung" class="section level4">
<h4>Gipfelerkennung</h4>
<p><em>Gipfel</em> können als Koordinaten einer morphometrisch analysierten räumlichen Umgebung betrachtet die eine gewisse Form aufwiesen betrachtet werden. Dies ermöglicht eine begründbare Ableitung von Gipfeln aufgrund von räumlichen Formmerkmalen. Hinsichtlich einer morphologischen und räumlichen Diskussion des Begriffs Gipfel und letztlich auch hinsichtlich der kognitiv-ästhetischen Betrachtungsweise des die Fragestellung initierenden Artikels erscheint dies als erfolgversprechender Ansatz. Wood (1996) diskutiert [( Wood, J.D. (1996) The geomorphological characterisation of digital elevation models PhD Thesis, University of Leicester, UK, <a href="http://www.soi.city.ac.uk/~jwo/phd" class="uri">http://www.soi.city.ac.uk/~jwo/phd</a>)]) das Potenzial, dass in einer multiskaligen, morphometrischen Analyse von Geländeformen liegt. Allerdings sind vor allem aufgrund der räumlichen Skalenübergange des betrachteten Formenschatzes erhebliche Unschärfen zu erwarten (vgl. Fisher et al. 2004 [(Fisher, P., Wood, J. and Cheng, T. (2004): Where is Helvellyn? Fuzziness of Multiscale Landscape Morphometry, Transactions of the Institute of British Geographers, 29(1), pp.106-128.)]. Die von Fisher et. al. 2004 diskutierten Unschärfen finden sich in der zuvor angesprochen geographisch geprägten kontroversen Entwicklung der Begrifflichkeit und Benennung solcher Formen in den unterschiedlichen orographischen Strukturen wieder (vgl. Rasemann (2003)[(#1)]. Berücksichtigt man diese Problematik erscheint es zumindest aus pragmatischer informationstechnischer Sicht als sinnvoll und berechtigt nur nach lokalen Maxima auf Grundlage der direkten Moore-Nachbarschaft <em>Gipfel</em> zu bestimmen.</p>
<p>Letztlich wird allerdings bereits hier deutlich, dass es je nach Zielsetzung, wesentlich sinnvoller sein könnte, nicht aus der Geländeform auf die Gipfel zu schliessen, sondern verfügbare Gipfelkoordinaten zb. “<em>Harry’s Gipfelliste</em>” [( Breitkreutz, H.: Gipfelliste <a href="http://www.tourenwelt.info/bergliste/bergliste.php" class="uri">http://www.tourenwelt.info/bergliste/bergliste.php</a>. URL:<a href="http://www.tourenwelt.info/commons/download/bergliste-komplett.kmz.php" class="uri">http://www.tourenwelt.info/commons/download/bergliste-komplett.kmz.php</a>. (Zugriff: 14.06.2012))] (natürlich mit namentlicher Zuweisung) im Relief zu verorten und das DGM <em>nur</em> zur Berechnung der Parameter heranzuziehen.</p>
<pre><code>#-------.
#   Gipfelerkennung
#-------.
# Variante A
# 1) Berechnung morhophometrischer Gipfel-Gridzellen *)
# 2) Gipfelgridzellen werden als Punktkkordinaten (Zentroid) mit ihrem Höhenwert extrahiert und 
# 3) als R-Tabelle verfügbar gemacht. 
#
# Varante B
# 1) Filterung der Daten (am einfachsten Mean oder Gauss)
# 2) Bestimmung aller lokalen Maxima
# 3) MAximum-Gridzellen werden als Punktkkordinaten mit ihrem Höhenwert extrahiert und
# 4) als R-Tabelle verfügbar gemacht.
#
# Variante C
# 1) Gipfelliste (z.B. http://www.tourenwelt.info) importieren und bereinigen (siehe Datenimport)
#   
#
# *) Wood, J.D. (1996) The geomorphological characterisation of digital elevation models, http://www.soi.city.ac.uk/~jwo/phd
#-------.

if (wood==T) { # Gipfelerkennung nach Wood (1996)
## Der Parameter s_tol bestimmt die Krümmungstoleranz der Gipfelfäche, c_tol der Krümmungstoleranz von Ebenen 
## size gibt die zur Berechnung verwendete Kernel-Größe (Moore-Nachbarschaft) in Pixel an
execGRASS(&quot;r.param.scale&quot;, flags=c(&quot;overwrite&quot;), input=&quot;DGM&quot;, output=&quot;gipfel&quot;, s_tol=1.0, c_tol=0.00001, size=as.integer(3), param=&quot;feature&quot;)

# Export aus GRASS des Gipfelerkennung als GEOTIFF
execGRASS(&quot;r.out.gdal&quot;, input=&quot;gipfel&quot;, output=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/peak_form.tif&quot;)

## Import GEOTIFF  Gipfelerkennung nach SAGA ACHTUNG Bennennung muss GRIDS und FILES heissen NICHT GRID/FILENAME
rsaga.geoprocessor(&quot;io_gdal&quot;,0,env=myenv,list(GRIDS=&quot;peak_form.sgrd&quot; , FILES=&quot;peak_form.tif&quot;))


## Wood bestimmt 6 Form-Klassen
## 1=planar,2=pit,3=channel,4=pass,5=ridge,6=peak
## Da uns nur 6=peak interessiert müssen wir das grid
## reklassifizieren. GRASS benötigt hierzu eine Textdatei
## mit Regeln falls die Textdatei &quot;reclass&quot; bereit existiert 
## wird sie mit dem Systembefehl &quot;rm reclass&quot; gelöscht
system(&quot;rm reclass&quot;)

## Erzeugen (linux shell) einer Lookuptabelle zur Reklassifizierung der morphometrischen Berechnung
## peak werden zu 1 alle anderen Werte zu 0
system(&quot;echo &#39;6 = 1  
* = NULL 
                 end&#39;   &gt;&gt;  reclass&quot; )

## reklassifizierung unter Verwendung der erzeugten Datei reclass
execGRASS(&quot;r.reclass&quot;,flags=c(&quot;overwrite&quot;), input=&quot;gipfel&quot;, output=&quot;gipfel_bool&quot;, rules=&quot;reclass&quot;)

## Da Gipfel nach Wood anders als lokale Maxima Gebiete ähnlicher Form sind
## können sie z.T. viele einzelene (zusammenhängende) Pixel umfassen
## Ein einfacher Weg aus diesen einen Punkt zu erzeugen ist die Umwandlung der 
## reklassifizierten Raster-Daten in Gipfel-Vektor-Polygone
execGRASS(&quot;r.to.vect&quot;, flags=c(&quot;overwrite&quot;), input=&quot;gipfel_bool&quot;, output=&quot;gipfel_vpoly_bool&quot;, feature=&quot;area&quot;)

## Von diesen Poolygonen wird der Zentroid (Flächenschwerpunkt) berechnet und ausschreiben der centroid punkte der Gipfel-Polygone
## um den Gipfel als Punktkoordinate zu erhalten
execGRASS(&quot;v.type&quot;, flags=c(&quot;overwrite&quot;),input=&quot;gipfel_vpoly_bool&quot;, output=&quot;gipfel_vpoint_bool&quot;, type=&quot;centroid,point&quot;)

## Zur Speicherung der Höhenwerte aus dem Geländemodell
## muss der erzeugten Vektordatei erst eine neue Attributspalte 
## in der Attributtabelle hinzugefügt werden 
execGRASS(&quot;v.db.addcol&quot;, map=&quot;gipfel_vpoint_bool&quot;, columns=&quot;heights double precision&quot;)

## Jetzt noch die Höhenwerte an den Centroid-Koordinaten 
## aus dem DGM Raster extrahieren und in die neue Spalte schreiben
execGRASS(&quot;v.what.rast&quot;, vector=&quot;gipfel_vpoint_bool&quot;, raster=&quot;DGM&quot;, column=&quot;heights&quot;)
gipfel=read.csv(&quot;gipfel.csv&quot;, header = FALSE, sep = &quot;&quot;, dec=&quot;.&quot;)
# Löschen der Variable 3 (ID der Vektordatei)
gipfel$V3 &lt;- NULL

} # Ende Wood -----------------------------------------------------------------


# Beginn MaxPix -----------------------------------------------------------------
if (max==T){ #maxPix
  # Gipfelerkennung &quot;lokale Maxima&quot; METHOD=0 ist der MEAN Filter
  
  ## Auschreiben der Reclass Tabelle für SAGA. 
  ## Achtung die DateiDARF NICHT beim Einlesen nach SAGA die Endung csv haben!
  ## AUSSERDEM MUSS sie 6 Ziffern nach dem Dezimalpunkt aufweisen (nsmall = 6)
#  hoehe =minGipfelhoehe
#  rec &lt;- structure(list(MIN = c(0.0), MAX = c(hoehe), CODE = c(0.0)), .Names = c(&quot;MIN&quot;,&quot;MAX&quot;, &quot;CODE&quot;), row.names = c(NA,1L), class = &quot;data.frame&quot;)
#  write.table(format(rec, nsmall = 6), &quot;rec.txt&quot;,row.names = FALSE, quote = F, sep =&quot;\t&quot;)
  
  ## Reklassifizieren des GRIDS
#  rsaga.geoprocessor(&quot;grid_tools&quot;,15,list(INPUT=&quot;DGM.sgrd&quot;,RESULT=&quot;DGMrec&quot;,METHOD=2,RETAB=&quot;rec.txt&quot;,ROPERATOR=1 ))
  
  rsaga.geoprocessor(&quot;grid_filter&quot;,0,list(INPUT=&quot;DGM.sgrd&quot;,RESULT=&quot;fDGM&quot;,MODE=0,METHOD=0,RADIUS=filterumgebung))
  
 
  # Shapes_Grid extrahiert lokale Maxima und Minima Positionen und ihre Höhenwerte (peaks und pits) in shapefiles
  rsaga.geoprocessor(&quot;shapes_grid&quot;,9,list(GRID=&quot;fDGM.sgrd&quot;, MAXIMA=&quot;localmax&quot;,MINIMA=&quot;localmin&quot;))       
  
  # Das localmax shapefile enthält in der Spalte Z die Höhenwerte wird hier in eine CSV Textdatei exportiert
  rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;localmax.shp&quot;,FIELD=&quot;Z&quot;,SEPARATE=0,FILENAME=&quot;gipfel.csv&quot;))
  
  ## die csv datei der Gipfel (gleichgültig welche)  wird in die R-Tabelle gipfel geschrieben
  gipfel=read.csv(&quot;gipfel.csv&quot;, header = FALSE, sep = &quot;&quot;)
  # es werden Spaltennamen zuweisen
  colnames(gipfel)=c(&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;)
  
} # Ende max--------------------------------------------------------------------



# Beginn Gipfelliste -----------------------------------------------------------------
if (gipfelliste==T){ 
# ermitteln des Extend damit ein polygon zum clippen erzeugt werden kann
rsaga.geoprocessor(&quot;grid_tools&quot;,15,list(INPUT=&quot;fDGM.sgrd&quot;,RESULT=&quot;extent&quot;, METHOD=0, OLD=9999.,NEW=100,SOPERATOR=1))
# erzeugen des Polygons
rsaga.geoprocessor(&quot;shapes_grid&quot;,10,list(SHAPES=&quot;umfang.shp&quot;, CELLS=&quot;0&quot;, PARAMETERS_GRID_SYSTEM_NX=&quot;1277&quot;,  PARAMETERS_GRID_SYSTEM_NY=&quot;1120&quot;, PARAMETERS_GRID_SYSTEM_X=&quot;577537.5&quot;,PARAMETERS_GRID_SYSTEM_Y=&quot;5211037.5&quot;,PARAMETERS_GRID_SYSTEM_D=&quot;75&quot;))

#### einmal der durchgang 1) Einlesen 2) projizieren 3) clippen für die (von hand korrigierte) CSV liste
rsaga.geoprocessor(&quot;io_shapes&quot;,3,list(SHAPES=&quot;bergliste5.shp&quot;, X_FIELD=2,Y_FIELD=1,FILENAME=&quot;bergliste-komplett_16.05_2012.csv&quot;))
rsaga.geoprocessor(&quot;pj_proj4&quot;,5,list(SOURCE_PROJ=&quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0&quot;,TARGET_PROJ=&quot;+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs +towgs84=0,0,0&quot;,SOURCE=&quot;bergliste5.shp&quot;,TARGET=&quot;bergliste5_utm.shp&quot;))
rsaga.geoprocessor(&quot;shapes_points&quot;,8,list(POINTS=&quot;bergliste5_utm.shp&quot; ,POLYGONS=&quot;umfang.shp&quot; ,CLIPS=&quot;bergliste5_cut.shp&quot;, METHOD=&quot;0&quot;))

#### einmal der durchgang 1) Einlesen 2) projizieren 3) clippen für die gpx liste
rsaga.geoprocessor(&quot;io_shapes&quot;,13,list(SHAPES=&quot;bergliste.shp&quot;,FILE=&quot;bergliste-komplett.gpx&quot;))
rsaga.geoprocessor(&quot;pj_proj4&quot;,5,list(SOURCE_PROJ=&quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0&quot;,TARGET_PROJ=&quot;+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs +towgs84=0,0,0&quot;,SOURCE=&quot;bergliste.shp&quot;,TARGET=&quot;bergliste_utm.shp&quot;))
rsaga.geoprocessor(&quot;shapes_points&quot;,8,list(POINTS=&quot;bergliste_utm.shp&quot; ,POLYGONS=&quot;umfang.shp&quot; ,CLIPS=&quot;bergliste_cut.shp&quot;, METHOD=&quot;0&quot;))

### Todo Merge der beiden listen

# in eine CSV Textdatei exportiert
rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;bergliste5_cut.shp&quot;,  ALL=T, SEPARATE=1,FILENAME=&quot;gipfel.txt&quot;))

## die csv datei der Gipfel (gleichgültig welche)  wird in die R-Tabelle gipfel geschrieben
gipfel=read.csv(&quot;gipfel.csv&quot;, header = FALSE, sep = &quot;,&quot;)
# es werden Spaltennamen zuweisen
colnames(gipfel)=c(&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;)

} # Ende Gipfelliste</code></pre>
<p><img src="images/dgm_s_tol1_1_c_tol_0_0004.png" /></p>
<p>Beispiel Gipfelerkennung Lahnberge im Raum Marburg</p>
</div>
<div id="berechnung-der-dominanz" class="section level4">
<h4>Berechnung der Dominanz</h4>
<p>Hier wird für jeden Gipfel ein “proximity Grid” erstellt, was für jeden Pixel die Entfernung zum Gipfel enthält. Zusätzlich wird ein binäres Raster erstellt, welches eine 1 für höhere Pixel und eine 0 für niedrigere Pixel als der Gipfel enthält. Diese Grids werden multipliziert. Der niedrigste Wert davon ist dann die Dominanz. Diese wird als neue Spalte in die Tabelle “gipfel” geschrieben.</p>
<p><img src="images/dominanz.png" />
Berechnung der Dominanz</p>
<pre><code>#-------.
#   Dominanz
#-------.
# 1) Für jede Gipfel-Koordionate wird mit &quot;proximity&quot; ein Distanz-Grid erstellt
#    (Resultat ist die Entfernung jedes Pixels zum Gipfel. 
# 2) Zusätzlich15wird ein Maske erstellt (1 height&gt;gipfel, 0 height &lt;= Gipfel
# 3) Dominanz=minimum(proximity*maske) 
# 4) Dominaz wird als neue Variable in die Tabelle &quot;gipfel&quot; eingetragen 
#-------.

for (i in 1: nrow(gipfel))                                                    # Für jeden Gipfel
{

  # Zeile vom Gipfel i als Text Tabelle speichern
  write.table(gipfel[i,],&quot;tmp1.txt&quot;,row.names=FALSE)                     
  
  # Tabelle in SAGA importieren
  rsaga.geoprocessor(&quot;io_table&quot;,1,env=myenv, list(TABLE=&quot;peak&quot;,HEADLINE=TRUE,SEPARATOR=&quot;space&quot;, FILENAME=&quot;tmp1.txt&quot;))
  
  # Tabellenimport in Shapedatei konvertieren
  rsaga.geoprocessor(&quot;shapes_points&quot;,0,env=myenv,list(POINTS=&quot;peak&quot;,TABLE=&quot;peak&quot;, X=&quot;X&quot;,Y=&quot;Y&quot;)) 
  
  # Erzeugte Shapedatei in eine Rasterdatei konvertieren ACHTUNG die Datei peak.sgrd muss bereits existieren!
  rsaga.geoprocessor(&quot;grid_gridding&quot;,0,list(INPUT=&quot;peak.shp&quot;, FIELD=&quot;X&quot;,LINE_TYPE=2,GRID_TYPE=3,TARGET=1,GRID_GRID=&quot;peak.sgrd&quot;))    
  
  
  ## Höhe vom Gipfel aufrunden (simpler workaround damit Pixelwert sicher höher ist als seine Nachbarpixel) 
  ## und in Variable hoehe schreiben
  hoehe=ceiling(gipfel$Z[i])        
  
  ## SAGA Single Reclass (Method = 0): Alle die &lt;Z =0 (SOPERATOR=3 heißt &lt;)
  #rsaga.geoprocessor(&quot;grid_tools&quot;,15,list(INPUT=&quot;fDGM.sgrd&quot;,RESULT=&quot;high_px&quot;, METHOD=2,SOPERATOR=1))
  ## SAGA Single Reclass (Method = 0): Alle Pixel die  &gt;= Z = 1 (SOPERATOR=3 heißt &gt;=)
  #rsaga.geoprocessor(&quot;grid_tools&quot;,15,list(INPUT=&quot;low_pix.sgrd&quot;, RESULT=&quot;high_pix&quot;,METHOD=0, OLD=hoehe,NEW=1,SOPERATOR=3))

  ## Auschreiben der Reclass Tabelle für SAGA. 
  ## Achtung die DateiDARF NICHT beim Einlesen nach SAGA die Endung csv haben!
  ## AUSSERDEM MUSS sie 6 Ziffern nach dem Dezimalpunkt aufweisen (nsmall = 6)
  rec &lt;- structure(list(MIN = c(0.0, hoehe), MAX = c(hoehe, 9999.0), CODE = c(0.0,1.0)), .Names = c(&quot;MIN&quot;,&quot;MAX&quot;, &quot;CODE&quot;), row.names = c(NA,2L), class = &quot;data.frame&quot;)
  write.table(format(rec, nsmall = 6), &quot;rec.txt&quot;,row.names = FALSE, quote = F, sep =&quot;\t&quot;)

  ## Reklassifizieren des GRIDS
  rsaga.geoprocessor(&quot;grid_tools&quot;,15,list(INPUT=&quot;fDGM.sgrd&quot;,RESULT=&quot;localmax&quot;,METHOD=2,RETAB=&quot;rec.txt&quot;,ROPERATOR=1 ))

  ## SAGA Proximity grid erstellen
  rsaga.geoprocessor(&quot;grid_tools&quot;,26,list(FEATURES=&quot;peak.sgrd&quot;,DISTANCE=&quot;proximity&quot;))
  
  ## Entfernunggrid (0/1) mit Höhengrid  multiplizieren
  rsaga.geoprocessor(&quot;grid_calculus&quot;,1,list(GRIDS=list(&quot;proximity.sgrd;high_pix.sgrd&quot;), RESULT=&quot;dominanz&quot;, FORMULA=&quot;a*b&quot;))
  
  ## Ergebnis in R verfügbar machen
  dominanz_grd=raster(&quot;dominanz.sgrd&quot;, band=1,native=TRUE)  
  tmp=getValues(dominanz_grd)
  if (any(tmp&gt;0)){                                        #geringste Distanz zu höheren =Dominanz
    gipfel$dominanz[i]=min(tmp[tmp&gt;0])                      #wird in gipfel-tabelle geschrieben
               

  } else {
    gipfel$dominanz[i]=max(tmp[tmp&gt;0])                         #Fall für höchsten Gipfel   
  }

  
}</code></pre>
</div>
<div id="berechnung-der-prominenz" class="section level4">
<h4>Berechnung der Prominenz</h4>
<div id="teil-1-graterkennung-und-schartenhöhenmatrix" class="section level5">
<h5>Teil 1 Graterkennung und Schartenhöhenmatrix ==</h5>
<p>Hier soll für jeden Gipfel die Schartenhöhe zu jedem anderen Gipfel ermittelt werden.
zunächst wird festgestellt, ob der Gipfel mit dem “Ziel-Gipfel” über einen
Grat verbunden ist. Wenn das der Fall ist, wird ein Höhenprofil aus dieser Verbindung
erstellt.Die minimale Höhe in diesem Profil ist dann die Schartenhöhe. Wenn die Gipfel
nicht verbunden sind,wird ein Höhenprofil aus der direkten Verbindung erstellt und der
min Wert davon ist die Schartenhöhe.</p>
<p><img src="images/schartenhoehe.png" /></p>
<p>Berechnung der Schartenhöhe</p>
<pre><code>
#-------.
#    SCHARTENHÖHE bzw. Prominenz   Variante B                                                                                                       
#-------.
#  1) Für jeden Gipfel wird die Schartenhöhe zu jedem höheren Gipfel ermittelt.                                           
#  2) Falls Gipfel1 und Gipfeln über einen Grat verbunden sind wird das Grat-Höhenprofil ermittelt                        
#  3) Die minimale Höhe des Profils ist die Schartenhöhe.                                                                 
#  4) Das Maximum aller ermittelten Schartenhöhen ist die gesuchte maximal Schartenhöhe                                   
#  5) Falls Gipfel und Zielgipfel NICHT über einen Grat miteinander verbunden sind wird ein Höhenprofil                   
#     aus der Sichtlinie zwischen den Gipfelpunkten erstellt dann weiter mit3) und 4)                                     
#-------.

##  Damit mit einer Flow-Analyse das Routing entlang der Grate Sattfinden kann
##  wird das gefilterte DGM invertiert
rsaga.geoprocessor(&quot;grid_calculus&quot;,1,list(GRIDS=&quot;fDGM.sgrd&quot;,RESULT=&quot;ifDGM&quot;,FORMULA=&quot;-a&quot;))

# Hydrologische Korrektur - Sink Removal Output: pitlessifDGM
rsaga.geoprocessor(&quot;ta_preprocessor&quot;,2,list(DEM=&quot;ifDGM.sgrd&quot;,DEM_PREPROC=&quot;pitlessifDGM&quot;, METHOD=1))

# Flow Analysis. Output: direction
rsaga.geoprocessor(&quot;ta_channels&quot;,5,list(DEM=&quot;pitlessifDGM.sgrd&quot;,DIRECTION=&quot;direction&quot;,CONNECTION=&quot;tmp&quot;, SEGMENTS=&quot;segments&quot;,BASINS=&quot;basins&quot;,THRESHOLD=0))

# Erzeugen einer Matrix für die Schartenhöhen
schartenhoehe=matrix(ncol=nrow(gipfel),nrow=nrow(gipfel)) 

# Füllen der Matrix mit NA
schartenhoehe=schartenhoehe==NA                            


for (i in 1:nrow(schartenhoehe))                                   # für jeden Gipfel
{
  
  write.table(gipfel[i,],&quot;tmp1.txt&quot;,row.names=F)               # Gipfelkoordinate die geroutet werden soll
  rsaga.geoprocessor(&quot;io_table&quot;,1, list(TABLE=&quot;DerGipfel&quot;,HEADLINE=TRUE,SEPARATOR=&quot;space&quot;,FILENAME=&quot;tmp1.txt&quot;))
  rsaga.geoprocessor(&quot;shapes_points&quot;,0,list(POINTS=&quot;ZielGipfel&quot;,TABLE=&quot;DerGipfel&quot;,X=&quot;X&quot;,Y=&quot;Y&quot;))
  if (i==1){schartenhoehe[i,1]=NA} 
  else     {if (i==2){
                      k=1
                      write.table((gipfel[k,]),&quot;tmp2.txt&quot;,row.names=F)
                      rsaga.geoprocessor(&quot;io_table&quot;,1, list(TABLE=&quot;AndereGipfel&quot;,HEADLINE=TRUE,SEPARATOR=&quot;space&quot;,FILENAME=&quot;tmp2.txt&quot;))
                      rsaga.geoprocessor(&quot;shapes_points&quot;,0,list(POINTS=&quot;Gipfelshp&quot;,TABLE=&quot;AndereGipfel&quot;,X=&quot;X&quot;,Y=&quot;Y&quot;))
                      rsaga.geoprocessor(&quot;shapes_tools&quot;,2,list(OUT=&quot;merged&quot;,MAIN=&quot;ZielGipfel.shp&quot;,LAYERS=&quot;Gipfelshp.shp&quot;))
                      rsaga.geoprocessor(&quot;grid_gridding&quot;,0,list(INPUT=&quot;merged.shp&quot;,FIELD=&quot;X&quot;,LINE_TYPE=2,GRID_TYPE=3,TARGET=1,GRID_GRID=&quot;tmp.sgrd&quot;))
                      rsaga.geoprocessor(&quot;ta_channels&quot;,0,list(ELEVATION=&quot;pitlessifDGM.sgrd&quot;,SINKROUTE=&quot;direction.sgrd&quot;,CHNLNTWRK=&quot;tmp&quot;,CHNLROUTE=&quot;tmp&quot;,SHAPES=&quot;line&quot;,INIT_GRID=&quot;tmp.sgrd&quot;,INIT_METHOD=2,INIT_VALUE=0,DIV_CELLS=5,MINLEN=10))    
                      rsaga.geoprocessor(&quot;shapes_polygons&quot;,6,list(SHAPES=&quot;line.shp&quot;,POINTS=&quot;networkpoints&quot;))
                      rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;networkpoints.shp&quot;,FIELD=&quot;Z&quot;,SEPARATE=0,FILENAME=&quot;Networkpoints.txt&quot;))
                      netpoints=read.table(&quot;Networkpoints.txt&quot;,header=F,sep=&quot;\t&quot;)       
       </code></pre>
<p>An dieser Stelle wurde jetzt versucht die Gipfel i und k über einen Grat zu verbinden. Falls das gelingt wird exakt ein Linienvektor zwischen den Gipfeln erzeugt.
In der Tabelle “netpoints” ist die ID dieser Linie enthalten. Es folglich nur eine ID geben, falls dies zutrifft, dann geht es wie folgt weiter:</p>
<pre><code>               if (substr(netpoints[1,3],1,2)==substr(netpoints[nrow(netpoints),3],1,2)) 
                         { # es darf nur eine durchgehende linie sein!!
                           rsaga.geoprocessor(&quot;ta_profiles&quot;,4,list(DEM=&quot;DGM.sgrd&quot;,LINES=&quot;line.shp&quot;,PROFILE=&quot;profile&quot;)) 
                           rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;profile.shp&quot;,FIELD=&quot;Z&quot;,SEPARATE=0,FILENAME=&quot;Elevprofile.txt&quot;))
                           elevprofile= read.table(&quot;Elevprofile.txt&quot;,header=F,sep=&quot;\t&quot;)   # lade die nach R
                           schartenhoehe[i,k]=min (elevprofile[,3])     </code></pre>
<p>Falls kein Grat zwischen den beiden Gipfeln i und k vorhanden ist, wird schlicht die Luftlinie verwendet:</p>
<pre><code>                      else
                          {    
                           for (k in 1:ncol(schartenhoehe[,1:(i-1)]))                         # für jeden anderen Berg (nicht doppelt berechnen!)
                               {
                                write.table((gipfel[k,]),&quot;tmp2.txt&quot;,row.names=F)
                                rsaga.geoprocessor(&quot;io_table&quot;,1, list(TABLE=&quot;AndereGipfel&quot;,HEADLINE=TRUE,SEPARATOR=&quot;space&quot;,FILENAME=&quot;tmp2.txt&quot;))
                                rsaga.geoprocessor(&quot;shapes_points&quot;,0,list(POINTS=&quot;Gipfelshp&quot;,TABLE=&quot;AndereGipfel&quot;,X=&quot;X&quot;,Y=&quot;Y&quot;))                  
                                rsaga.geoprocessor(&quot;shapes_tools&quot;,2,list(OUT=&quot;merged&quot;,MAIN=&quot;ZielGipfel.shp&quot;,LAYERS=&quot;Gipfelshp.shp&quot;))             
                                rsaga.geoprocessor(&quot;grid_gridding&quot;,0,list(INPUT=&quot;merged.shp&quot;,FIELD=&quot;X&quot;,LINE_TYPE=2,GRID_TYPE=3,TARGET=1,GRID_GRID=&quot;tmp.sgrd&quot;))  
                                rsaga.geoprocessor(&quot;ta_channels&quot;,0,list(ELEVATION=&quot;pitlessifDGM.sgrd&quot;,SINKROUTE=&quot;direction.sgrd&quot;,CHNLNTWRK=&quot;tmp&quot;,CHNLROUTE=&quot;tmp&quot;,SHAPES=&quot;line&quot;,INIT_GRID=&quot;tmp.sgrd&quot;,INIT_METHOD=2,INIT_VALUE=0,DIV_CELLS=5,MINLEN=10))      
                                rsaga.geoprocessor(&quot;shapes_polygons&quot;,6,list(SHAPES=&quot;line.shp&quot;,POINTS=&quot;networkpoints&quot;)) 
                                rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;networkpoints.shp&quot;,FIELD=&quot;Z&quot;,SEPARATE=0,FILENAME=&quot;Networkpoints.txt&quot;))
                                netpoints=read.table(&quot;Networkpoints.txt&quot;,header=F,sep=&quot;\t&quot;)  
                                if (substr(netpoints[1,3],1,2)==substr(netpoints[nrow(netpoints),3],1,2))        
                                   {        
                                    rsaga.geoprocessor(&quot;ta_profiles&quot;,4,list(DEM=&quot;DGM.sgrd&quot;,LINES=&quot;line.shp&quot;,PROFILE=&quot;profile&quot;))
                                    rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;profile.shp&quot;,FIELD=&quot;Z&quot;,SEPARATE=0,FILENAME=&quot;Elevprofile.txt&quot;))
                                    elevprofile= read.table(&quot;Elevprofile.txt&quot;,header=F,sep=&quot;\t&quot;)                                            
                                    schartenhoehe[i,k]=min (elevprofile[,3])    
                                    cat(&quot;Gipfel&quot;,i,&quot;von&quot;,nrow(gipfel),&quot;wird bearbeitet(&quot;,100*(k/ncol(schartenhoehe[,1:(i-1)])),&quot;%). Methode: Grat&quot;)
                                   }                    
                                 else
                                    {
                                     rsaga.geoprocessor(&quot;shapes_lines&quot;,1,list(LINES=&quot;line&quot;,POINTS=&quot;merged.shp&quot;,ORDER=&quot;Y&quot;))                           
                                     rsaga.geoprocessor(&quot;ta_profiles&quot;,4,list(DEM=&quot;DGM.sgrd&quot;,LINES=&quot;line.shp&quot;,PROFILE=&quot;profile&quot;))                 
                                     rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;profile.shp&quot;,FIELD=&quot;Z&quot;,SEPARATE=0,FILENAME=&quot;Elevprofile.txt&quot;))     
                                    elevprofile= read.table(&quot;Elevprofile.txt&quot;,header=F,sep=&quot;\t&quot;)                                                     
                                    schartenhoehe[i,k]=min (elevprofile[,3]) 
                                    cat(&quot;Gipfel&quot;,i,&quot;von&quot;,nrow(gipfel),&quot;wird bearbeitet(&quot;,100*(k/ncol(schartenhoehe[,1:(i-1)])),&quot;%). Methode: Sichtlinie&quot;)
                                    }
                              } 
                          }
       }
  cat(&quot;Gipfel&quot;,i,&quot;von&quot;,nrow(gipfel),&quot;fertig!&quot;)
  }


&lt;/code&gt;

Jetzt gibt es für jeden Berg zu jedem anderen Berg eine Schartenhöhe. Die Matrix wird jetzt gespiegelt, damit die Abfrage nacher einfacher ist:


&lt;code:rsplus&gt;
tmp=t(schartenhoehe)
schartenhoehe[is.na(schartenhoehe)]=tmp[is.na(schartenhoehe)]
write.table(schartenhoehe,&quot;MatrixSchartenhoehe.txt&quot;,row.names=F)                               # damit man es nicht immer neu rechnen muss ;)


</code></pre>
</div>
<div id="teil-2---abfrage-prominenz" class="section level5">
<h5>Teil 2 - Abfrage Prominenz ==</h5>
<p>Hier wird für jeden Gipfel abgefragt, welche Schartenhöhe zu einem höheren Gipfel die höchste ist.
Diese wird dann von der höhe des Gipfel subtrahiert und entspricht damit der Prominenz des Gipfels.
Die Prominenz wird als weitere Spalte der Tabelle “gipfel” angehängt. Der Fall für den höchsten Berg ist nicht optimal: Da es keinen höheren gibt kann auch keine Prominenz zugewiesen werden. Um den bedeutsamen Berg nicht auszuschließen wird daher hier die minimale Schartenhöhe, die überhaupt in der Matrix vorkommt verwendet.</p>
<pre><code>for (i in 1:nrow(gipfel))
{
  hoehere=which(gipfel$Z&gt;gipfel$Z[i])
  ifelse ((length(hoehere)==0),                                           #...wenn es keine höhere Gipfel gibt
         (gipfel$prominenz[i]=gipfel$Z[i]-min(schartenhoehe[i,],na.rm=T)),#nehme tiefste Verbindung überhaupt
         (gipfel$prominenz[i]=gipfel$Z[i]-max(schartenhoehe[i,hoehere]))) #sonst:maximale Schartenhöhe 
}
gipfel$prominenz[gipfel$prominenz&lt;0]=0.000001  #für den Fall das die Prominenz negativ ist weil Scharte größer
                                               #als Berg...Mit 0 kann man nachher nicht weiterrechnen, deshalb
                                               #wird eine Zahl fast 0 gewählt</code></pre>
</div>
</div>
<div id="berechnung-des-eigenständigkeitswertes" class="section level4">
<h4>Berechnung des Eigenständigkeitswertes</h4>
<p>Die Spalte “E” wird zu der Tabelle “gipfel” hinzugefügt und der Eigenständigkeitswert entsprechend der Formeln berechnet.</p>
<pre><code>gipfel$E[gipfel$dominanz&lt;100000]=-1*((logb((gipfel$Z/8848),base=2)+
                                  logb((gipfel$dominanz/100000),base=2)+
                                  logb((gipfel$p/gipfel$Z),base=2))/3)
gipfel$E[gipfel$dominanz&gt;=100000]=-1*((logb((gipfel$Z/8848),base=2)+
                                  logb((gipfel$p/gipfel$Z),base=2))/3)
</code></pre>
<p><img src="images/ergebnis.png" /></p>
<p>Ergebnis der Eigenständigkeitsberechnung</p>
</div>
<div id="vollständiges-r-grasssaga-skript" class="section level4">
<h4>Vollständiges R GRASS/SAGA Skript</h4>
<p>Das Skript hat sich von den oben beschriebenen Teilskripten einigermassen fortentwickelt. Sollte bei Gelegenheit angepasst werden. Allerdings sind die Grundkonzepte gleich geblieben.
Die Daten und die Verzeichnisstruktur gibts hier. Achtung alle Pfade etc. sollten überprüft werden. Fehler könnten an Schreibrechten liegen. bzw. das SAGA GRid-Dateien fehlen (Saga benötigt diese beim rastern von Vektordateien) {{:datenrsaga.zip|Download der Daten fürs Skript}}</p>
<pre><code># GipfelWert
# Version 0.9 
# Datum 16.06.2012
# Zweck:      R Skript nutzt SAGA und GRASS zur
#             Berechnung des Eigenständigkeitswert eines Gipfels nach Leonhard mit: 
#             h = Höhe                        (absolute Höhe des betrachteten Gipfels)
#             d = Dominanz                    (horizontale Distanz zum nächsten, höheren Geländepunkt)
#             p = Prominenz/Schartendifferenz (Höhendifferenz zur tiefsten Scharte im Verbindungsgrat 
#                                              zum nächsthöheren Gipfel)
# Quellen:    Rauch. C. (2012): Der perfekte Gipfel.  Panorama, 2/2012, S. 112 
#             http://www.alpenverein.de/dav-services/panorama-magazin/dominanz-prominenz-eigenstaendigkeit-eines-berges_aid_11186.html
#             (Zugriff: 20.05.2012)
#             Leonhard, W. (2012): Eigenständigkeit von Gipfeln. - 
#             Bergtouren. - http://www.thehighrisepages.de/bergtouren/na_orogr.htm
#             (Zugriff: 28.04.2012)
#             Wood, J.D. (1996) The geomorphological characterisation of digital elevation models, 
#             http://www.soi.city.ac.uk/~jwo/phd
#             (Zugriff: 20.05.2012)
#             Breitkreutz, H.: Gipfelliste http://www.tourenwelt.info/bergliste/bergliste.php. 
#             URL:http://www.tourenwelt.info/commons/download/bergliste-komplett.kmz.php 
#             (Zugriff: 14.06.2012)
#             SAGA Modulbeschreibungen:  http://sourceforge.net/apps/trac/saga-gis/wiki/Module%20Descriptions  
#             GRASS Modulbeschreibungen: http://wgbis.ces.iisc.ernet.in/grass/grass64/manuals/html64_user/index.html
#
# Autor(en):  Hanna Meyer (Basisskript R &amp; SAGA (Grate))
#             (c) Chris Reudenbach ( Erweiterung, Überarbeitung, Zusammenführung und Kommentare)
#             Kontakt: giswerk@gis-ma.org
# 
# Anmerkung:  Es wird nahezu ausschließlich mit den beiden generic wrappern rsaga.geoprocessor 
#             und execGRASS gearbeitet. Die packages RSAGA und spgrass6 bieten wesentlich effizientere 
#             z.T. Schnittstellen!
#             Vorteil der generischen Aufrufe ist, dass die Kommandozeilenaufrufe
#             der Pakete fast 1:1 genutzt werden können =&gt; steile Lernkurve
#             Achtung wer Rechner mit wenig Hauptspeicher hat sollte mit kleinen Datenmengen operieren. 
#             R ist da ganz schön lahm  :)
#-------.
# TODO:       Ne ganze Menge ;) Viel technische Optimierung siehe Kommentare
#             Vor allem aber konzeptionelle Verbesserungen
#             - Implementierung einer skaligen Gipfelsuche nach Wood (Schleife einbauen ;)
#             - Implementierung einer geeigneten Filtersuche             
#             - Optimierung der Gratsuche
#             - Automatische Korrektur der Gipfelliste 
#             - Implementierung von Regeln und Abfragen auf die &quot;Art&quot; des Gipfels
#                 - Landnutzung, Touren, Exposition Hütten etc. Hier gibts einen 
#                 - riesigen Datenfundus
#-------.
# Copyright: by-nc-sa 3.0 http://creativecommons.org/licenses/by-nc-sa/3.0/
#-------.


##Laden der grundlegenden libraries für die Verarbeitung räumlicher Daten
#-------.
library(sp)         # R spatial package
library(rgdal)      # R GDAL interface
library(maptools)   # R maptools package
library(spgrass6)   # R GRASS interface
library(RSAGA)      # R SAGA interface
library(raster)     # R raster package


## Arbeitsumgebung setzten
#-------.

# Arbeitsverzeichnis R
#-------.
setwd(&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA&quot;)
Rhome=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA&quot;


# Pfade und SETUP für GRASS 
#-------.

initGRASS(gisBase=&quot;/usr/lib/grass64&quot;, home=tempdir(), 
          gisDbase=&quot;/home/creu/workspace/grassprojects&quot;, 
          location=&quot;GIPFEL&quot;, mapset=&quot;SRTM&quot;,
          override=TRUE) 

# INFOS zum MAPSET
gmeta6()
str(gmeta6())

# Pfade und SETUP für SAGA 
#-------.

rsaga.env(workspace=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA&quot;)
myenv=rsaga.env(workspace=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA&quot;,path=&quot;/usr/local/bin&quot;,modules=&quot;/usr/local/lib/saga&quot;)
SHome=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA&quot;

# Globale Variablen 
#-------.
filterumgebung=45
#minGipfelhoehe=900


## Schalter für Gipfelvarianten 
## max = lokale Maxima 
## wood = morphometrische Berechnung nach Wood
## gipfelliste = Gipfelinfos von http://www.tourenwelt.info/
max = T
wood = F
gipfelliste = F

## Schalter für Prominez 
## flut = Flutungskonzept  (noch nicht implementiert)
## grat = Graterkennung
flut = T
if (flut==T){grat = F} else {grat==T}


#-------.
#   Daten Import/Export
#-------.
#  Es werden einige Möglichkeiten aufgezeigt verschiedene Daten für die weitere Verarbeitung verfügbar zumachen.
# 1) Datenimport aus XYZ Daten des Landesvermessungsamtes
# 2) Datenimport aus SRTM GEOTIFF Binärdaten 
#    jeweils in SAGA, GRASS, R 
#-------.
# Anmerkungen:
# Für alle weiteren Bedürfnisse muss leider auf die Modulbeschreibungen etc. verwiesen werden. 
# GEO-Datenhandling ist dank GDAL/OGR VIEL leichter geworden gehört aber immer noch mit zum Lästigsten überhaupt  
#-------.



## Import nach GRASS von XYZ ASCII Daten mit SPACE &quot; &quot; getrennt und Punkt &quot;.&quot; als Dezimaltrennzeichen Achtung x=RW y=HW Z=h GAUSSKRüger DHDN 3 (so kommts vom LVA)
#execGRASS(&quot;r.in.xyz&quot;, flags=c(&quot;overwrite&quot;), input=&quot;/home/creu/workspace//grassprojects/GIPFEL/SRTM/DGM10_3436996_5583209.xyz&quot;, output=&quot;DGM_1&quot;,  fs=&quot; &quot;, y=as.integer(2),x=as.integer(1), z=as.integer(3),pth=as.integer(1), zscale=1.0,percent=as.integer(100))

## Import nach SAGA von XYZ ASCII Daten mit SPACE &quot; &quot; getrennt und Punkt &quot;.&quot; als Dezimaltrennzeichen Achtung x=RW y=HW Z=h GAUSSKRüger DHDN 3 (so kommts vom LVA)
#rsaga.geoprocessor(&quot;io_grid&quot;,6,env=myenv,list(FILENAME=&quot;DGM10_3436996_5583209.xyz&quot;, GRID=&quot;DG&quot;, CELLSIZE=&quot;10&quot;,SEPARATOR=&quot;space&quot;))

## Import nach R von XYZ ASCII Daten mit SPACE &quot; &quot; getrennt und Punkt &quot;.&quot; als Dezimaltrennzeichen Achtung kein header!
#dor &lt;- read.table(&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/DGM10_3436996_5583209.xyz&quot;, header=F)

## Import nach GRASS von GDAL GeoTIFF Daten Achtung dise müssen zuvor projiziert sein
execGRASS(&quot;r.in.gdal&quot;, flags=c(&quot;overwrite&quot;), input=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/srtm_39_03/srtm_39_03utm.tif&quot;, output=&quot;DGM&quot;)


## Export von GRASS als GEOTIFF 
## (Workaround ist z.B. für SAGA statt direktem Auschreiben notwendig wegen möglicher NAN Fehler in der GDAL Bib)
## Wird hier gemacht6 weils unten je nach Algorithmus mit SAGA Formaten weitergeht 
execGRASS(&quot;r.out.gdal&quot;, flags=c(&quot;c&quot;),input=&quot;DGM&quot;, type=&quot;Float32&quot;, output=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/DGM.tif&quot;)
           
## Import SAGA ACHTUNG Bennennung muss GRIDS und FILES heissen NICHT GRID/FILENAME
rsaga.geoprocessor(&quot;io_gdal&quot;,0,env=myenv,list(GRIDS=&quot;DGM.sgrd&quot; , FILES=&quot;DGM.tif&quot;))

if (gipfelliste==T){
## Tourenwelt Bergliste enthält den wohl aktuellsten Datensatz zu Gipfeln 
## Der wird im folgenden geladen eingelesen reprojiziert und auf das Untersuchunggebiet ausgeschitten
## benötigt Internet
## TODO &quot;shapes_grid&quot;,10 benötigt noch die von Hand eingetragfenen Parameter des Grids 
## Die Projektion ist auf UTM festverdrahtet muss also für jede U-Gebiet angepasst werden  
## Die Bergliste muss noch geparst werden da so nur die Koordinaten + Namen (gpx import) oder alles nur keine namen Cvs import
## verfügbar sind (warum auch immer) ALTERNATIVE reverse Geocoding
## Natürlich könnte man auch ein bisschen tricksen. 
## 1) konvertieren als CVS dann austausch der HTM Zeichen von hand oder mit kommandozeile
## 2) Import des ganzen als gpx alles wegschmeisen bis auf koordinaten und Namen
## 3) Merge von beiden
# download der datei
system(&quot;wget http://www.tourenwelt.info/commons/download/bergliste-komplett.kmz.php&quot;)
# umbenenen da gunzip nur .gz verarbeitet
system(&quot;mv /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.kmz.php /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.gz&quot;)
# entzippen da es sich um kmz handelt pgsbabel aber nur kml kann
system(&quot;gunzip -f /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.gz&quot;)
#anhängen der  kml endung
system(&quot;mv -f /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.kml&quot;)
# export als gpx datei
system(&quot;gpsbabel -i kml -f /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.kml -o gpx -F /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.gpx&quot;)
#export als csv datei
system(&quot;gpsbabel -i kml -f /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.kml -o unicsv -F /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/bergliste-komplett.csv&quot;)
}


#-------.
#   Gipfelerkennung
#-------.
# Variante A
# 1) Berechnung morhophometrischer Gipfel-Gridzellen *)
# 2) Gipfelgridzellen werden als Punktkkordinaten (Zentroid) mit ihrem Höhenwert extrahiert und 
# 3) als R-Tabelle verfügbar gemacht. 
#
# Varante B
# 1) Filterung der Daten (am einfachsten Mean oder Gauss)
# 2) Bestimmung aller lokalen Maxima
# 3) MAximum-Gridzellen werden als Punktkkordinaten mit ihrem Höhenwert extrahiert und
# 4) als R-Tabelle verfügbar gemacht.
#
# Variante C
# 1) Gipfelliste (z.B. http://www.tourenwelt.info) importieren und bereinigen (siehe Datenimport)
#   
#
# *) Wood, J.D. (1996) The geomorphological characterisation of digital elevation models, http://www.soi.city.ac.uk/~jwo/phd
#-------.

if (wood==T) { # Gipfelerkennung nach Wood (1996)
## Der Parameter s_tol bestimmt die Krümmungstoleranz der Gipfelfäche, c_tol der Krümmungstoleranz von Ebenen 
## size gibt die zur Berechnung verwendete Kernel-Größe (Moore-Nachbarschaft) in Pixel an
execGRASS(&quot;r.param.scale&quot;, flags=c(&quot;overwrite&quot;), input=&quot;DGM&quot;, output=&quot;gipfel&quot;, s_tol=1.0, c_tol=0.00001, size=as.integer(3), param=&quot;feature&quot;)

# Export aus GRASS des Gipfelerkennung als GEOTIFF
execGRASS(&quot;r.out.gdal&quot;, input=&quot;gipfel&quot;, output=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/peak_form.tif&quot;)

## Import GEOTIFF  Gipfelerkennung nach SAGA ACHTUNG Bennennung muss GRIDS und FILES heissen NICHT GRID/FILENAME
rsaga.geoprocessor(&quot;io_gdal&quot;,0,env=myenv,list(GRIDS=&quot;peak_form.sgrd&quot; , FILES=&quot;peak_form.tif&quot;))


## Wood bestimmt 6 Form-Klassen
## 1=planar,2=pit,3=channel,4=pass,5=ridge,6=peak
## Da uns nur 6=peak interessiert müssen wir das grid
## reklassifizieren. GRASS benötigt hierzu eine Textdatei
## mit Regeln falls die Textdatei &quot;reclass&quot; bereit existiert 
## wird sie mit dem Systembefehl &quot;rm reclass&quot; gelöscht
system(&quot;rm reclass&quot;)

## Erzeugen (linux shell) einer Lookuptabelle zur Reklassifizierung der morphometrischen Berechnung
## peak werden zu 1 alle anderen Werte zu 0
system(&quot;echo &#39;6 = 1  
* = NULL 
                 end&#39;   &gt;&gt;  reclass&quot; )

## reklassifizierung unter Verwendung der erzeugten Datei reclass
execGRASS(&quot;r.reclass&quot;,flags=c(&quot;overwrite&quot;), input=&quot;gipfel&quot;, output=&quot;gipfel_bool&quot;, rules=&quot;reclass&quot;)

## Da Gipfel nach Wood anders als lokale Maxima Gebiete ähnlicher Form sind
## können sie z.T. viele einzelene (zusammenhängende) Pixel umfassen
## Ein einfacher Weg aus diesen einen Punkt zu erzeugen ist die Umwandlung der 
## reklassifizierten Raster-Daten in Gipfel-Vektor-Polygone
execGRASS(&quot;r.to.vect&quot;, flags=c(&quot;overwrite&quot;), input=&quot;gipfel_bool&quot;, output=&quot;gipfel_vpoly_bool&quot;, feature=&quot;area&quot;)

## Von diesen Poolygonen wird der Zentroid (Flächenschwerpunkt) berechnet und ausschreiben der centroid punkte der Gipfel-Polygone
## um den Gipfel als Punktkoordinate zu erhalten
execGRASS(&quot;v.type&quot;, flags=c(&quot;overwrite&quot;),input=&quot;gipfel_vpoly_bool&quot;, output=&quot;gipfel_vpoint_bool&quot;, type=&quot;centroid,point&quot;)

## Zur Speicherung der Höhenwerte aus dem Geländemodell
## muss der erzeugten Vektordatei erst eine neue Attributspalte 
## in der Attributtabelle hinzugefügt werden 
execGRASS(&quot;v.db.addcol&quot;, map=&quot;gipfel_vpoint_bool&quot;, columns=&quot;heights double precision&quot;)

## Jetzt noch die Höhenwerte an den Centroid-Koordinaten 
## aus dem DGM Raster extrahieren und in die neue Spalte schreiben
execGRASS(&quot;v.what.rast&quot;, vector=&quot;gipfel_vpoint_bool&quot;, raster=&quot;DGM&quot;, column=&quot;heights&quot;)
gipfel=read.csv(&quot;gipfel.csv&quot;, header = FALSE, sep = &quot;&quot;, dec=&quot;.&quot;)
# Löschen der Variable 3 (ID der Vektordatei)
gipfel$V3 &lt;- NULL

} # Ende Wood -----------------------------------------------------------------


# Beginn MaxPix -----------------------------------------------------------------
if (max==T){ #maxPix
  # Gipfelerkennung &quot;lokale Maxima&quot; METHOD=0 ist der MEAN Filter
  
  ## Auschreiben der Reclass Tabelle für SAGA. 
  ## Achtung die DateiDARF NICHT beim Einlesen nach SAGA die Endung csv haben!
  ## AUSSERDEM MUSS sie 6 Ziffern nach dem Dezimalpunkt aufweisen (nsmall = 6)
#  hoehe =minGipfelhoehe
#  rec &lt;- structure(list(MIN = c(0.0), MAX = c(hoehe), CODE = c(0.0)), .Names = c(&quot;MIN&quot;,&quot;MAX&quot;, &quot;CODE&quot;), row.names = c(NA,1L), class = &quot;data.frame&quot;)
#  write.table(format(rec, nsmall = 6), &quot;rec.txt&quot;,row.names = FALSE, quote = F, sep =&quot;\t&quot;)
  
  ## Reklassifizieren des GRIDS
#  rsaga.geoprocessor(&quot;grid_tools&quot;,15,list(INPUT=&quot;DGM.sgrd&quot;,RESULT=&quot;DGMrec&quot;,METHOD=2,RETAB=&quot;rec.txt&quot;,ROPERATOR=1 ))
  
  rsaga.geoprocessor(&quot;grid_filter&quot;,0,list(INPUT=&quot;DGM.sgrd&quot;,RESULT=&quot;fDGM&quot;,MODE=0,METHOD=0,RADIUS=filterumgebung))
  
 
  # Shapes_Grid extrahiert lokale Maxima und Minima Positionen und ihre Höhenwerte (peaks und pits) in shapefiles
  rsaga.geoprocessor(&quot;shapes_grid&quot;,9,list(GRID=&quot;fDGM.sgrd&quot;, MAXIMA=&quot;localmax&quot;,MINIMA=&quot;localmin&quot;))       
  
  # Das localmax shapefile enthält in der Spalte Z die Höhenwerte wird hier in eine CSV Textdatei exportiert
  rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;localmax.shp&quot;,FIELD=&quot;Z&quot;,SEPARATE=0,FILENAME=&quot;gipfel.csv&quot;))
  
  ## die csv datei der Gipfel (gleichgültig welche)  wird in die R-Tabelle gipfel geschrieben
  gipfel=read.csv(&quot;gipfel.csv&quot;, header = FALSE, sep = &quot;&quot;)
  # es werden Spaltennamen zuweisen
  colnames(gipfel)=c(&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;)
  
} # Ende max--------------------------------------------------------------------



# Beginn Gipfelliste -----------------------------------------------------------------
if (gipfelliste==T){ 
# ermitteln des Extend damit ein polygon zum clippen erzeugt werden kann
rsaga.geoprocessor(&quot;grid_tools&quot;,15,list(INPUT=&quot;fDGM.sgrd&quot;,RESULT=&quot;extent&quot;, METHOD=0, OLD=9999.,NEW=100,SOPERATOR=1))
# erzeugen des Polygons
rsaga.geoprocessor(&quot;shapes_grid&quot;,10,list(SHAPES=&quot;umfang.shp&quot;, CELLS=&quot;0&quot;, PARAMETERS_GRID_SYSTEM_NX=&quot;1277&quot;,  PARAMETERS_GRID_SYSTEM_NY=&quot;1120&quot;, PARAMETERS_GRID_SYSTEM_X=&quot;577537.5&quot;,PARAMETERS_GRID_SYSTEM_Y=&quot;5211037.5&quot;,PARAMETERS_GRID_SYSTEM_D=&quot;75&quot;))

#### einmal der durchgang 1) Einlesen 2) projizieren 3) clippen für die (von hand korrigierte) CSV liste
rsaga.geoprocessor(&quot;io_shapes&quot;,3,list(SHAPES=&quot;bergliste5.shp&quot;, X_FIELD=2,Y_FIELD=1,FILENAME=&quot;bergliste-komplett_16.05_2012.csv&quot;))
rsaga.geoprocessor(&quot;pj_proj4&quot;,5,list(SOURCE_PROJ=&quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0&quot;,TARGET_PROJ=&quot;+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs +towgs84=0,0,0&quot;,SOURCE=&quot;bergliste5.shp&quot;,TARGET=&quot;bergliste5_utm.shp&quot;))
rsaga.geoprocessor(&quot;shapes_points&quot;,8,list(POINTS=&quot;bergliste5_utm.shp&quot; ,POLYGONS=&quot;umfang.shp&quot; ,CLIPS=&quot;bergliste5_cut.shp&quot;, METHOD=&quot;0&quot;))

#### einmal der durchgang 1) Einlesen 2) projizieren 3) clippen für die gpx liste
rsaga.geoprocessor(&quot;io_shapes&quot;,13,list(SHAPES=&quot;bergliste.shp&quot;,FILE=&quot;bergliste-komplett.gpx&quot;))
rsaga.geoprocessor(&quot;pj_proj4&quot;,5,list(SOURCE_PROJ=&quot;+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs +towgs84=0,0,0&quot;,TARGET_PROJ=&quot;+proj=utm +zone=32 +ellps=WGS84 +datum=WGS84 +units=m +no_defs +towgs84=0,0,0&quot;,SOURCE=&quot;bergliste.shp&quot;,TARGET=&quot;bergliste_utm.shp&quot;))
rsaga.geoprocessor(&quot;shapes_points&quot;,8,list(POINTS=&quot;bergliste_utm.shp&quot; ,POLYGONS=&quot;umfang.shp&quot; ,CLIPS=&quot;bergliste_cut.shp&quot;, METHOD=&quot;0&quot;))

### Todo Merge der beiden listen

# in eine CSV Textdatei exportiert
rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;bergliste5_cut.shp&quot;,  ALL=T, SEPARATE=1,FILENAME=&quot;gipfel.txt&quot;))

## die csv datei der Gipfel (gleichgültig welche)  wird in die R-Tabelle gipfel geschrieben
gipfel=read.csv(&quot;gipfel.csv&quot;, header = FALSE, sep = &quot;,&quot;)
# es werden Spaltennamen zuweisen
colnames(gipfel)=c(&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;)

} # Ende Gipfelliste


# Weiter mit Dominanz -----------------------------------------------------------------
## Nun weiter mit der Verarbeitung


                            

#-------.
#   Dominanz
#-------.
# 1) Für jede Gipfel-Koordionate wird mit &quot;proximity&quot; ein Distanz-Grid erstellt
#    (Resultat ist die Entfernung jedes Pixels zum Gipfel. 
# 2) Zusätzlich wird ein Maske erstellt (1 height&gt;gipfel, 0 height &lt;= Gipfel
# 3) Dominanz=minimum(proximity*maske) 
# 4) Dominaz wird als neue Variable in die Tabelle &quot;gipfel&quot; eingetragen 
#-------.

for (i in 1: nrow(gipfel))                                                    # Für jeden Gipfel
{

  # Zeile vom Gipfel i als Text Tabelle speichern
  write.table(gipfel[i,],&quot;tmp1.txt&quot;,row.names=FALSE)                     
  
  # Tabelle in SAGA importieren
  rsaga.geoprocessor(&quot;io_table&quot;,1,env=myenv, list(TABLE=&quot;peak&quot;,HEADLINE=TRUE,SEPARATOR=&quot;space&quot;, FILENAME=&quot;tmp1.txt&quot;))
  
  # Tabellenimport in Shapedatei konvertieren
  rsaga.geoprocessor(&quot;shapes_points&quot;,0,env=myenv,list(POINTS=&quot;peak&quot;,TABLE=&quot;peak&quot;, X=&quot;X&quot;,Y=&quot;Y&quot;)) 
  
  # Erzeugte Shapedatei in eine Rasterdatei konvertieren ACHTUNG die Datei peak.sgrd muss bereits existieren!
  rsaga.geoprocessor(&quot;grid_gridding&quot;,0,list(INPUT=&quot;peak.shp&quot;, FIELD=&quot;X&quot;,LINE_TYPE=2,GRID_TYPE=3,TARGET=1,GRID_GRID=&quot;peak.sgrd&quot;))    
  
  
  ## Höhe vom Gipfel aufrunden (simpler workaround damit Pixelwert sicher höher ist als seine Nachbarpixel) 
  ## und in Variable hoehe schreiben
  hoehe=ceiling(gipfel$Z[i])        
  
  ## SAGA Single Reclass (Method = 0): Alle die &lt;Z =0 (SOPERATOR=3 heißt &lt;)
  #rsaga.geoprocessor(&quot;grid_tools&quot;,15,list(INPUT=&quot;fDGM.sgrd&quot;,RESULT=&quot;high_px&quot;, METHOD=2,SOPERATOR=1))
  ## SAGA Single Reclass (Method = 0): Alle Pixel die  &gt;= Z = 1 (SOPERATOR=3 heißt &gt;=)
  #rsaga.geoprocessor(&quot;grid_tools&quot;,15,list(INPUT=&quot;low_pix.sgrd&quot;, RESULT=&quot;high_pix&quot;,METHOD=0, OLD=hoehe,NEW=1,SOPERATOR=3))

  ## Auschreiben der Reclass Tabelle für SAGA. 
  ## Achtung die DateiDARF NICHT beim Einlesen nach SAGA die Endung csv haben!
  ## AUSSERDEM MUSS sie 6 Ziffern nach dem Dezimalpunkt aufweisen (nsmall = 6)
  rec &lt;- structure(list(MIN = c(0.0, hoehe), MAX = c(hoehe, 9999.0), CODE = c(0.0,1.0)), .Names = c(&quot;MIN&quot;,&quot;MAX&quot;, &quot;CODE&quot;), row.names = c(NA,2L), class = &quot;data.frame&quot;)
  write.table(format(rec, nsmall = 6), &quot;rec.txt&quot;,row.names = FALSE, quote = F, sep =&quot;\t&quot;)

  ## Reklassifizieren des GRIDS
  rsaga.geoprocessor(&quot;grid_tools&quot;,15,list(INPUT=&quot;fDGM.sgrd&quot;,RESULT=&quot;localmax&quot;,METHOD=2,RETAB=&quot;rec.txt&quot;,ROPERATOR=1 ))

  ## SAGA Proximity grid erstellen
  rsaga.geoprocessor(&quot;grid_tools&quot;,26,list(FEATURES=&quot;peak.sgrd&quot;,DISTANCE=&quot;proximity&quot;))
  
  ## Entfernunggrid (0/1) mit Höhengrid  multiplizieren
  rsaga.geoprocessor(&quot;grid_calculus&quot;,1,list(GRIDS=list(&quot;proximity.sgrd;high_pix.sgrd&quot;), RESULT=&quot;dominanz&quot;, FORMULA=&quot;a*b&quot;))
  
  ## Ergebnis in R verfügbar machen
  dominanz_grd=raster(&quot;dominanz.sgrd&quot;, band=1,native=TRUE)  
  tmp=getValues(dominanz_grd)
  if (any(tmp&gt;0)){                                        #geringste Distanz zu höheren =Dominanz
    gipfel$dominanz[i]=min(tmp[tmp&gt;0])                      #wird in gipfel-tabelle geschrieben
               

  } else {
    gipfel$dominanz[i]=max(tmp[tmp&gt;0])                         #Fall für höchsten Gipfel   
  }

  
}


#-------.
#    SCHARTENHÖHE bzw. Prominenz   Variante B                                                                                                       
#-------.
#  1) Für jeden Gipfel wird die Schartenhöhe zu jedem höheren Gipfel ermittelt.                                           
#  2) Falls Gipfel1 und Gipfeln über einen Grat verbunden sind wird das Grat-Höhenprofil ermittelt                        
#  3) Die minimale Höhe des Profils ist die Schartenhöhe.                                                                 
#  4) Das Maximum aller ermittelten Schartenhöhen ist die gesuchte maximal Schartenhöhe                                   
#  5) Falls Gipfel und Zielgipfel NICHT über einen Grat miteinander verbunden sind wird ein Höhenprofil                   
#     aus der Sichtlinie zwischen den Gipfelpunkten erstellt dann weiter mit3) und 4)                                     
#-------.

##  Damit mit einer Flow-Analyse das Routing entlang der Grate Sattfinden kann
##  wird das gefilterte DGM invertiert
rsaga.geoprocessor(&quot;grid_calculus&quot;,1,list(GRIDS=&quot;fDGM.sgrd&quot;,RESULT=&quot;ifDGM&quot;,FORMULA=&quot;-a&quot;))

# Hydrologische Korrektur - Sink Removal Output: pitlessifDGM
rsaga.geoprocessor(&quot;ta_preprocessor&quot;,2,list(DEM=&quot;ifDGM.sgrd&quot;,DEM_PREPROC=&quot;pitlessifDGM&quot;, METHOD=1))

# Flow Analysis. Output: direction
rsaga.geoprocessor(&quot;ta_channels&quot;,5,list(DEM=&quot;pitlessifDGM.sgrd&quot;,DIRECTION=&quot;direction&quot;,CONNECTION=&quot;tmp&quot;, SEGMENTS=&quot;segments&quot;,BASINS=&quot;basins&quot;,THRESHOLD=0))

# Erzeugen einer Matrix für die Schartenhöhen
schartenhoehe=matrix(ncol=nrow(gipfel),nrow=nrow(gipfel)) 

# Füllen der Matrix mit NA
schartenhoehe=schartenhoehe==NA                            


for (i in 1:nrow(schartenhoehe))                                   # für jeden Gipfel
{
  
  write.table(gipfel[i,],&quot;tmp1.txt&quot;,row.names=F)               # Gipfelkoordinate die geroutet werden soll
  rsaga.geoprocessor(&quot;io_table&quot;,1, list(TABLE=&quot;DerGipfel&quot;,HEADLINE=TRUE,SEPARATOR=&quot;space&quot;,FILENAME=&quot;tmp1.txt&quot;))
  rsaga.geoprocessor(&quot;shapes_points&quot;,0,list(POINTS=&quot;ZielGipfel&quot;,TABLE=&quot;DerGipfel&quot;,X=&quot;X&quot;,Y=&quot;Y&quot;))
  if (i==1){schartenhoehe[i,1]=NA} 
  else     {if (i==2){
                      k=1
                      write.table((gipfel[k,]),&quot;tmp2.txt&quot;,row.names=F)
                      rsaga.geoprocessor(&quot;io_table&quot;,1, list(TABLE=&quot;AndereGipfel&quot;,HEADLINE=TRUE,SEPARATOR=&quot;space&quot;,FILENAME=&quot;tmp2.txt&quot;))
                      rsaga.geoprocessor(&quot;shapes_points&quot;,0,list(POINTS=&quot;Gipfelshp&quot;,TABLE=&quot;AndereGipfel&quot;,X=&quot;X&quot;,Y=&quot;Y&quot;))
                      rsaga.geoprocessor(&quot;shapes_tools&quot;,2,list(OUT=&quot;merged&quot;,MAIN=&quot;ZielGipfel.shp&quot;,LAYERS=&quot;Gipfelshp.shp&quot;))
                      rsaga.geoprocessor(&quot;grid_gridding&quot;,0,list(INPUT=&quot;merged.shp&quot;,FIELD=&quot;X&quot;,LINE_TYPE=2,GRID_TYPE=3,TARGET=1,GRID_GRID=&quot;tmp.sgrd&quot;))
                      rsaga.geoprocessor(&quot;ta_channels&quot;,0,list(ELEVATION=&quot;pitlessifDGM.sgrd&quot;,SINKROUTE=&quot;direction.sgrd&quot;,CHNLNTWRK=&quot;tmp&quot;,CHNLROUTE=&quot;tmp&quot;,SHAPES=&quot;line&quot;,INIT_GRID=&quot;tmp.sgrd&quot;,INIT_METHOD=2,INIT_VALUE=0,DIV_CELLS=5,MINLEN=10))    
                      rsaga.geoprocessor(&quot;shapes_polygons&quot;,6,list(SHAPES=&quot;line.shp&quot;,POINTS=&quot;networkpoints&quot;))
                      rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;networkpoints.shp&quot;,FIELD=&quot;Z&quot;,SEPARATE=0,FILENAME=&quot;Networkpoints.txt&quot;))
                      netpoints=read.table(&quot;Networkpoints.txt&quot;,header=F,sep=&quot;\t&quot;)       
                      if (substr(netpoints[1,3],1,2)==substr(netpoints[nrow(netpoints),3],1,2)) 
                         { # es darf nur eine durchgehende linie sein!!
                           rsaga.geoprocessor(&quot;ta_profiles&quot;,4,list(DEM=&quot;DGM.sgrd&quot;,LINES=&quot;line.shp&quot;,PROFILE=&quot;profile&quot;)) 
                           rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;profile.shp&quot;,FIELD=&quot;Z&quot;,SEPARATE=0,FILENAME=&quot;Elevprofile.txt&quot;))
                           elevprofile= read.table(&quot;Elevprofile.txt&quot;,header=F,sep=&quot;\t&quot;)   # lade die nach R
                           schartenhoehe[i,k]=min (elevprofile[,3])     
                         }                  
                          else  # wenn berg nicht durch grat verbunden
                              {   # linie dazwischen
                                rsaga.geoprocessor(&quot;shapes_lines&quot;,1,list(LINES=&quot;line&quot;,POINTS=&quot;merged.shp&quot;,ORDER=&quot;Y&quot;))
                                rsaga.geoprocessor(&quot;ta_profiles&quot;,4,list(DEM=&quot;DGM.sgrd&quot;,LINES=&quot;line.shp&quot;,PROFILE=&quot;profile&quot;))
                                rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;profile.shp&quot;,FIELD=&quot;Z&quot;,SEPARATE=0,FILENAME=&quot;Elevprofile.txt&quot;))
                                elevprofile= read.table(&quot;Elevprofile.txt&quot;,header=F,sep=&quot;\t&quot;)                  # lade die nach R
                                schartenhoehe[i,k]=min (elevprofile[,3])                              # min Schartenhöhen zu allen anderen Gipfeln
                              }
                     }
                      else
                          {    
                           for (k in 1:ncol(schartenhoehe[,1:(i-1)]))                         # für jeden anderen Berg (nicht doppelt berechnen!)
                               {
                                write.table((gipfel[k,]),&quot;tmp2.txt&quot;,row.names=F)
                                rsaga.geoprocessor(&quot;io_table&quot;,1, list(TABLE=&quot;AndereGipfel&quot;,HEADLINE=TRUE,SEPARATOR=&quot;space&quot;,FILENAME=&quot;tmp2.txt&quot;))
                                rsaga.geoprocessor(&quot;shapes_points&quot;,0,list(POINTS=&quot;Gipfelshp&quot;,TABLE=&quot;AndereGipfel&quot;,X=&quot;X&quot;,Y=&quot;Y&quot;))                  
                                rsaga.geoprocessor(&quot;shapes_tools&quot;,2,list(OUT=&quot;merged&quot;,MAIN=&quot;ZielGipfel.shp&quot;,LAYERS=&quot;Gipfelshp.shp&quot;))             
                                rsaga.geoprocessor(&quot;grid_gridding&quot;,0,list(INPUT=&quot;merged.shp&quot;,FIELD=&quot;X&quot;,LINE_TYPE=2,GRID_TYPE=3,TARGET=1,GRID_GRID=&quot;tmp.sgrd&quot;))  
                                rsaga.geoprocessor(&quot;ta_channels&quot;,0,list(ELEVATION=&quot;pitlessifDGM.sgrd&quot;,SINKROUTE=&quot;direction.sgrd&quot;,CHNLNTWRK=&quot;tmp&quot;,CHNLROUTE=&quot;tmp&quot;,SHAPES=&quot;line&quot;,INIT_GRID=&quot;tmp.sgrd&quot;,INIT_METHOD=2,INIT_VALUE=0,DIV_CELLS=5,MINLEN=10))      
                                rsaga.geoprocessor(&quot;shapes_polygons&quot;,6,list(SHAPES=&quot;line.shp&quot;,POINTS=&quot;networkpoints&quot;)) 
                                rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;networkpoints.shp&quot;,FIELD=&quot;Z&quot;,SEPARATE=0,FILENAME=&quot;Networkpoints.txt&quot;))
                                netpoints=read.table(&quot;Networkpoints.txt&quot;,header=F,sep=&quot;\t&quot;)  
                                if (substr(netpoints[1,3],1,2)==substr(netpoints[nrow(netpoints),3],1,2))        
                                   {        
                                    rsaga.geoprocessor(&quot;ta_profiles&quot;,4,list(DEM=&quot;DGM.sgrd&quot;,LINES=&quot;line.shp&quot;,PROFILE=&quot;profile&quot;))
                                    rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;profile.shp&quot;,FIELD=&quot;Z&quot;,SEPARATE=0,FILENAME=&quot;Elevprofile.txt&quot;))
                                    elevprofile= read.table(&quot;Elevprofile.txt&quot;,header=F,sep=&quot;\t&quot;)                                            
                                    schartenhoehe[i,k]=min (elevprofile[,3])    
                                    cat(&quot;Gipfel&quot;,i,&quot;von&quot;,nrow(gipfel),&quot;wird bearbeitet(&quot;,100*(k/ncol(schartenhoehe[,1:(i-1)])),&quot;%). Methode: Grat&quot;)
                                   }                    
                                 else
                                    {
                                     rsaga.geoprocessor(&quot;shapes_lines&quot;,1,list(LINES=&quot;line&quot;,POINTS=&quot;merged.shp&quot;,ORDER=&quot;Y&quot;))                           
                                     rsaga.geoprocessor(&quot;ta_profiles&quot;,4,list(DEM=&quot;DGM.sgrd&quot;,LINES=&quot;line.shp&quot;,PROFILE=&quot;profile&quot;))                 
                                     rsaga.geoprocessor(&quot;io_shapes&quot;,2,list(SHAPES=&quot;profile.shp&quot;,FIELD=&quot;Z&quot;,SEPARATE=0,FILENAME=&quot;Elevprofile.txt&quot;))     
                                    elevprofile= read.table(&quot;Elevprofile.txt&quot;,header=F,sep=&quot;\t&quot;)                                                     
                                    schartenhoehe[i,k]=min (elevprofile[,3]) 
                                    cat(&quot;Gipfel&quot;,i,&quot;von&quot;,nrow(gipfel),&quot;wird bearbeitet(&quot;,100*(k/ncol(schartenhoehe[,1:(i-1)])),&quot;%). Methode: Sichtlinie&quot;)
                                    }
                              } 
                          }
       }
  cat(&quot;Gipfel&quot;,i,&quot;von&quot;,nrow(gipfel),&quot;fertig!&quot;)
  }

tmp=t(schartenhoehe)
schartenhoehe[is.na(schartenhoehe)]=tmp[is.na(schartenhoehe)]
write.table(schartenhoehe,&quot;MatrixSchartenhoehe.txt&quot;,row.names=F)                               # damit man es nicht immer neu rechnen muss ;)

#-------.
# Prominenz
#-------.
# Abfrage auf jeden Gipfel zu welchem der höheren Gipfel die Schartenhöhe am höchsten ist.
# Diese wird dann von der höhe des Gipfel subtrahiert und entspricht damit der Prominenz des Gipfels.
#-------.
for (i in 1:nrow(gipfel))
{
  hoehere=which(gipfel$Z&gt;gipfel$Z[i])
  ifelse ((length(hoehere)==0), (gipfel$prominenz[i]=gipfel$Z[i]-min(schartenhoehe[i,],na.rm=T)),   
          (gipfel$prominenz[i]=gipfel$Z[i]-max(schartenhoehe[i,hoehere])))                   #noch nicht optimal: dem höchsten Berg kann man hier eigentlich keine prominenz zuweisen
}
gipfel$prominenz[gipfel$prominenz&lt;0]=0.000001                                                #für den Fall das die Prominenz negativ ist weil scharte größer als Berg...??


#-------.
#   Eigenständigkeitswert
#-------.
gipfel$E[gipfel$dominanz&lt;100000]=-1*((logb((gipfel$Z/8848),base=2)+logb((gipfel$dominanz/100000),base=2)+logb((gipfel$p/gipfel$Z),base=2))/3)
gipfel$E[gipfel$dominanz&gt;=100000]=-1*((logb((gipfel$Z/8848),base=2)+logb((gipfel$p/gipfel$Z),base=2))/3)
write.table(gipfel,&quot;gipfel.csv&quot;,row.names=F,sep=&quot;;&quot;)

#-------.
#                                Finde &quot;perfekten&quot; Gipfel
#-------.
Ziel=gipfel
Ziel=Ziel[order(Ziel$E,decreasing=F),]
write.table(Ziel,&quot;ziel.csv&quot;,row.names=F,sep=&quot;;&quot;)

rsaga.geoprocessor(&quot;io_gdal&quot;,1,list(
  GRIDS=&quot;DGM.sgrd&quot;,
  FILE=&quot;DGM.rst&quot;,
  FORMAT=14,
  TYPE=0))                                                                     # export als rst (warum eigentlich?)
demS=raster(&quot;DGM.rst&quot;)                                                                # lade in R
cols=c(&quot;red&quot;,&quot;orange&quot;,&quot;yellow&quot;,&quot;green&quot;,&quot;blue&quot;)
pdf(&quot;/home/creu/workspace/peak/V1/Top5.pdf&quot;)
plot(demS,ylab=&quot;Y&quot;,xlab=&quot;X&quot;,main=&quot;Die 5 &#39;besten&#39; Gipfel&quot;,col= terrain.colors(20),zlim=c(0,500),ylim=c(5620000,5637500)) # plot Top 5
points(Ziel[1:5,]$X,Ziel[1:5,]$Y,pch=16,col=cols,cex=2)
par(xpd=T)
text(15.2,50,&quot;Elevation (m)&quot;,cex=0.8)
legend(&quot;topright&quot;,pch=16,col=cols,legend=c(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;),bty=&quot;n&quot;,horiz=T)
dev.off()

#-------.  
#                                Dies&amp;Das
#-------.


# --------- Exkurs Import Export Plotten ----------------------
## export der erzeugten Vektordatei 

## Und weils so schön ist hier der Export des  Punkt-Shapefiles g.shp als ASCII XYZ File (Option 2) in die Datei gipfel.csv
#rsaga.geoprocessor(&quot;io_shapes&quot;,2,env=myenv,list(SHAPES=&quot;g.shp&quot;,FIELD=&quot;heights&quot;,SEPARATE=0, FILENAME=&quot;gipfel.csv&quot;))

## falls die auszuschreibende SHapedatei g.* bereit existiert wird sie mit dem Systembefehl gelöscht
##system(&quot;rm /home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/g.*&quot;)

## aus GRASS ins SHAPEformat
##execGRASS(&quot;v.out.ogr&quot;,  input=&quot;gipfel_vpoint_bool&quot;, type=&quot;point&quot;, dsn=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/g.shp&quot;)
## aus GRASS ins ASCII XYZ Format
###execGRASS(&quot;v.out.ascii&quot;, input=&quot;gipfel_vpoint_bool&quot;, output=&quot;/home/creu/workspace/grassprojects/GIPFEL/SRTM/RSAGA/gipfel.csv&quot;, columns=&quot;heights&quot;, format=&quot;point&quot;,fs=&quot; &quot;)

# Import SHAPE Punkte in R
##xx &lt;- readShapePoints(&quot;/home/creu/workspace/peak/V1/g.shp&quot;)
## dimensions(xx)
##summary(xx)

## plotten der Punkte
##plot(xx,col=&quot;red&quot;, add=TRUE)

##schreibt man die Ausgabebefehle (plot, image etc)
## zwischen die Anweisungen png() dev.off() wird alles in die Grafikdatei geleitet
##png(&quot;gipfel.png&quot;)
##plot(xx,col=&quot;red&quot;, add=TRUE)
##dev.off()
# --------- Exkurs Import Export Plotten ----------------------


###Plot Zwischenschritte
rsaga.geoprocessor(&quot;io_gdal&quot;,1,list(
  GRIDS=&quot;DGM.sgrd&quot;,
  FILE=&quot;DGM.rst&quot;,
  FORMAT=14,
  TYPE=0))#import demsmooth nach rst
dem=raster(&quot;DGM.rst&quot;)                                                                       # lade in R
pdf(&quot;/home/creu/workspace/peak/V1/DEMS.pdf&quot;,width=10,height=5)
par(mfrow=c(1,2),mar=c(4.2,4.2,1,5.2))
plot(dem,ylab=&quot;Y&quot;,xlab=&quot;X&quot;,main=&quot;Raw DEM&quot;,col= terrain.colors(20),zlim=c(0,500))                # plot Top 10
plot(demS,ylab=&quot;Y&quot;,xlab=&quot;X&quot;,main=&quot;DEM und Lage der Gipfel&quot;,col= terrain.colors(20),zlim=c(0,500))
points(gipfel$X,gipfel$Y,pch=16,cex=1)
par(xpd=T)
text(15.2,50,&quot;Elevation (m)&quot;,cex=0.8)
dev.off()

###Hilfe 
#rsaga.get.modules(); z.B. rsaga.get.usage(&quot;io_grid&quot;,6)
#-------.
#
#-------.
rsaga.geoprocessor(&quot;io_shapes&quot;,3,env=myenv,list(SHAPES=&quot;GipfelShape&quot;,X_FIELD=1,Y_FIELD=2,FILENAME=&quot;gipfel.xyz&quot;))
</code></pre>
<p>[#1] ^, ^ <a href="http://www.alpenverein.de/dav-services/panorama-magazin/dominanz-prominenz-eigenstaendigkeit-eines-berges_aid_11186.html" class="uri">http://www.alpenverein.de/dav-services/panorama-magazin/dominanz-prominenz-eigenstaendigkeit-eines-berges_aid_11186.html</a>
[#2] ^, ^ Bernhard, W., Eigenständigkeit von Gipfeln, <a href="http://www.thehighrisepages.de/bergtouren/na_orogr.htm#BK" class="uri">http://www.thehighrisepages.de/bergtouren/na_orogr.htm#BK</a> , Letzter Zugriff: 1.5.2012
[#3] ^ Rasemann, S. (2004), Geomorphometrische Struktur eines mesoskaligen alpinen Geosystems, Asgard-Verlag, St. Augustin, Bonner Geographische Abhandlungen, Heft Nr. 111, URL: <a href="http://hss.ulb.uni-bonn.de/2003/0211/0211.htm" class="uri">http://hss.ulb.uni-bonn.de/2003/0211/0211.htm</a>
[#4] ^ Aster: <a href="http://www.jspacesystems.or.jp/ersdac/GDEM/E/" class="uri">http://www.jspacesystems.or.jp/ersdac/GDEM/E/</a>
[#5] ^ SRTM: <a href="http://srtm.csi.cgiar.org/" class="uri">http://srtm.csi.cgiar.org/</a>
[#6] ^ Wood, J.D. (1996) The geomorphological characterisation of digital elevation models PhD Thesis, University of Leicester, UK, <a href="http://www.soi.city.ac.uk/~jwo/phd" class="uri">http://www.soi.city.ac.uk/~jwo/phd</a>
[#7] ^ Fisher, P., Wood, J. and Cheng, T. (2004): Where is Helvellyn? Fuzziness of Multiscale Landscape Morphometry, Transactions of the Institute of British Geographers, 29(1), pp.106-128.
[#8] ^ Breitkreutz, H.: Gipfelliste <a href="http://www.tourenwelt.info/bergliste/bergliste.php" class="uri">http://www.tourenwelt.info/bergliste/bergliste.php</a>. URL:<a href="http://www.tourenwelt.info/commons/download/bergliste-komplett.kmz.php" class="uri">http://www.tourenwelt.info/commons/download/bergliste-komplett.kmz.php</a>. (Zugriff: 14.06.2012</p>
</div>
</div>
</div>
</div>

                <style>
.button {
  border: none;
  border-radius: 4px 4px; 
  color: white;
  padding: 2px 4px;
  text-align: center;
  text-decoration: none;
  display: inline-block;
  font-size: 12px;
  transition-duration: 0.5s;
  cursor: pointer;
  background-color: #4CAF50; 
  
}
.button1 a:link {
  color: #FFF;
  border-radius: 4px 4px;        
  background-color: #4CAF50; 
  
}

.button1 a:visited {
  color: white;
    border-radius: 4px 4px;        
  background-color: #4CAF50; 
  
}

.button1 a:hover {
  color: white;
    padding: 2px 4px;
    border-radius: 4px 4px;        
  background-color: #3FA043; 
  
}

.button1 a:active {
  color: white;
    border-radius: 4px 4px;        
  background-color: #4CAF50; 
  
}
}

.button1 {
  color: white;
  border-radius: 4px 4px;        
  background-color: #4CAF50; 
  
}


.button1:hover {
  background-color: #4CAF60;
    box-shadow:0 8px 16px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)
}

</style>


<div class="col-12 col-lg-10ish article-style">     
<p>Questions and mistakes but also suggestions and solutions are welcome.</p>
<script src="https://utteranc.es/client.js"
        repo="gisma-courses/gi-modules"
        issue-term="title"
        label="comments"
        theme="github-light"
        crossorigin="anonymous" 
        async>
</script>
<p>Due to an occasionally faulty page redirection, a 404 error may occur. please use the alternative <button class="button button1"> <a href="https://api.utteranc.es/authorize?redirect_uri=https%3a%2f%2fgisma-courses.github.io%2fgi-modules%2fpost%2f2022-03-13-der-perfekte-gipfel%2f">Sign in with GitHub</a></button></p>
    
</div>

                
                
                <hr>
                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/gi-modules/post/2022-02-15-analysis-of-massive-sentinel-data-using-stac-and-gdalcubes/" data-toggle="tooltip" data-placement="top" title="Analysis of massive Remote Sensing data">&larr;
                            Previous Post</a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/gi-modules/post/2021-11-13-project-oriented-workflow/" data-toggle="tooltip" data-placement="top" title="Project-Oriented Workflow">Next
                            Post &rarr;</a>
                    </li>
                    
                </ul>

            </div>

            
            
            <div class="
                col-lg-2 col-lg-offset-0
                visible-lg-block
                sidebar-container
                catalog-container">
                <div class="side-catalog">
                    <hr class="hidden-sm hidden-xs">
                    <h5>
                        <a class="catalog-toggle" href="#">Content</a>
                    </h5>
                    <ul class="catalog-body"></ul>
                </div>
            </div>
            
            
            

            
            <div class="
                col-lg-2 col-lg-offset-0
                col-md-3 col-md-offset-1
                sidebar-container
                catalog-container">

                
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">Tag Nav</a></h5>
                    <div class="tags">
                        
                        
                        
                        <a href="/gi-modules/tags/change-detection" title="change-detection">
                            change-detection
                        </a>
                        
                        
                        
                        <a href="/gi-modules/tags/ecology" title="ecology">
                            ecology
                        </a>
                        
                        
                        
                        <a href="/gi-modules/tags/forest" title="forest">
                            forest
                        </a>
                        
                        
                        
                        <a href="/gi-modules/tags/gis" title="gis">
                            gis
                        </a>
                        
                        
                        
                        <a href="/gi-modules/tags/lidar" title="lidar">
                            lidar
                        </a>
                        
                        
                        
                        <a href="/gi-modules/tags/project-management" title="project-management">
                            project-management
                        </a>
                        
                        
                        
                        <a href="/gi-modules/tags/remote-sensing" title="remote-sensing">
                            remote-sensing
                        </a>
                        
                        
                        
                        <a href="/gi-modules/tags/reproducibility" title="reproducibility">
                            reproducibility
                        </a>
                        
                        
                        
                        <a href="/gi-modules/tags/resources" title="resources">
                            resources
                        </a>
                        
                        
                        
                        <a href="/gi-modules/tags/rmarkdown" title="rmarkdown">
                            rmarkdown
                        </a>
                        
                        
                        
                        <a href="/gi-modules/tags/scidoc" title="scidoc">
                            scidoc
                        </a>
                        
                        
                        
                        <a href="/gi-modules/tags/scripts" title="scripts">
                            scripts
                        </a>
                        
                        
                        
                        <a href="/gi-modules/tags/xtra" title="xtra">
                            xtra
                        </a>
                        
                        
                    </div>
                </section>
                 

                
                
                      
            </div>
        </div>
    </div>
</article>




<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                   
                    

                    
                    
                    

                    

		    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
            
            
            
                </ul>
		<p class="copyright text-muted">
                    Copyright &copy; gi-modules 2022
                    <br>
                    <a href="https://themes.gohugo.io/hugo-theme-cleanwhite">CleanWhite Hugo Theme</a> by <a href="https://zhaohuabing.com">Huabing</a> 
                </p>
            </div>
        </div>
    </div>
</footer>




<script>
    function loadAsync(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

  
  <script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>




<script>
    
    if($('#tag_cloud').length !== 0){
        loadAsync("/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>


<script>
    loadAsync("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>









<script type="text/javascript">
    function generateCatalog(selector) {

        
        
        
        
            _containerSelector = 'div.post-container'
        

        
        var P = $(_containerSelector), a, n, t, l, i, c;
        a = P.find('h1,h2,h3,h4,h5,h6');

        
        $(selector).html('')

        
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            i = "#" + $(this).prop('id');
            t = $(this).text();
            c = $('<a href="' + i + '" rel="nofollow">' + t + '</a>');
            l = $('<li class="' + n + '_nav"></li>').append(c);
            $(selector).append(l);
        });
        return true;
    }

    generateCatalog(".catalog-body");

    
    $(".catalog-toggle").click((function (e) {
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    


    loadAsync("\/gi-modules\/js\/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });
    
</script>
    



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bash.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="//yihui.name/js/math-code.js"></script>
<script async
src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


</body>
</html>
