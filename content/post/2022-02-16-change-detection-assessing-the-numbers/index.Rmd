---
title: 'Change Detection - Auswertung der Klassifikationsdaten '
author: Chris Reudenbach
date: '2022-02-16'
bibliography: references.bib
slug: []
categories:
  - bGIS
tags:
  - Remote Sensing
subtitle: ''
description: 'Da in jeder Klassifizierung von Daten immer Fehlklassifikationen vorkommen und die Ursachen vielfältiger Art sein können und häufig nicht bestimbar sind, ist ist die Bewertung der Qualität von zentraler Bedeutung um die Belastbarkeit der Klassifikation einschätzen zu können.'
image: '/assets/images/forest-sp.jpg'
toc: yes
output:
  blogdown::html_page:
    keep_md: yes
weight: 502
---

Da in jeder Klassifizierung von Daten immer Fehlklassifikationen vorkommen und die Ursachen vielfältiger Art sein können und häufig nicht bestimbar sind, ist ist die Bewertung der Qualität von zentraler Bedeutung um die Belastbarkeit der Klassifikation einschätzen zu können. Der nachfolgende Artikel beschäftigt sich mich den grundlegensten Bewertungsmethden.

## Setup

Das Einlesen der Daten aus der Klassifikation.

```{r setup , echo=TRUE, message = FALSE, warnings = FALSE, results = FALSE}

#
# Type: script
# Name: change_detection_workflow.R
# Description:  basic reproducible Change Detection workflow for Sentinel data
#               data download -> digitizing training areas ->
#               extracting and preparing training data ->
#               example classifications: cluster analysis, random forest, MaxLike
#               quality assesment and comparison with basic tools, kappa, and motif
#               basic visualisation examples with tmap and mapview
# Dependencies:
# Output: original sentinel tile
#         AOI window of this tile (research_area)
#         training areas
# Copyright: GPL (>= 3), Chris Reudenbach, creuden@gmail.com
#

#--- laden der notwendigen Bibliotheken
# Achtung Pakete müssen evtl. manuell installiert werden
library(envimaR)

## setzen des aktuellen Projektverzeichnisses (erstellt mit envimaR) als root_folder
#root_folder = find_rstudio_root_file()
root_folder = "~/edu/geoinfo/"

# einlesen des zuvor erstellten Setup-Skripts
source(file.path(root_folder, "src/functions/000_setup.R"))
source(file.path(root_folder, "src/functions/fun_helper.R"))
source(file.path(root_folder, "src/functions/fun_kappa.R"))
source(file.path(root_folder, "src/functions/fun_tmap.R"))
```


## Einlesen der Datensätze

```{r download, comment = NA, echo=TRUE, message = FALSE, warnings = FALSE, results = FALSE }

# größe der Aggregationsfesnter für die CD Auswertung Distanz-Schwellenwert
# "dist" ist abhängig von wins_size je kleiner win_size desto größer der
# Schwellenwert
win_size = 25

#--- Download der Daten
train_areas_2019 = readRDS(paste0(envrmt$path_data,"train_areas_2019.rds"))
train_areas_2020 = readRDS(paste0(envrmt$path_data,"train_areas_2020.rds"))

prediction_rf_2019 = readRDS(paste0(envrmt$path_data,"pred_rf_2019.rds"))
prediction_rf_2020 = readRDS(paste0(envrmt$path_data,"pred_rf_2020.rds"))

prediction_mlc_2019 = readRDS(paste0(envrmt$path_data,"pred_mlc_2019.rds"))
prediction_mlc_2020 = readRDS(paste0(envrmt$path_data,"pred_mlc_2020.rds"))

# ansonsten den Beipieldatensatz laden
corine = raster::raster(file.path(envrmt$path_data_lev0,"corine.tif"))

# Erstellen einer Wald-Maske
# Agro-forestry areas code=22, Broad-leaved forest code=23,
# Coniferous forest code=24, Mixed forest code=25
mask = reclassify(corine,c(-100,22,0,22,26,1,26,500,0))

```


## Fehlereinschätzung 

Die Bewertung der Genauigkeit von Fernerkundungsklassifizierungen basiert in der Regel auf der Verwendung einer Fehlermatrix oder Konfusionstabelle, für die Referenzdaten oder "Ground Truthing" benötigt werden. Diese Bewertungen  können qualitativ, d. h. in der Regel durch einen visuellen Vergleich zwischen dem klassifizierten Datensatz und der Situation vor Ort (im Luft-/satellitenbild) oder quantitativ durch den Vergleich der klassifizierten Daten untereinander oder mit unabhängigen Referenzdaten erfolgen.


Die wichtigsten Fehlerursachen sind:

*  Qualität der Eingangsdaten
*  die Eignung des Klassifizierungsalgorithmus im Kontext mit den Trainingsdaten
*  die generelle Trennbarkeit der auszuweisenden Klassen

Es gilt generell folgende Bereiche einzuschätzen:

* Gesamtgenauigkeit der Klassifikationskarte (zusammengesetzt aus der Genauigkeit der einzelnen Klassen)
* Fehlklassifikation je Klasse (inkl. Fehlzuordnung je Klasse)


Die Validierungsdaten bzw. der sog *Ground Truth* ist für die Berechnung elementar. Üblich sind Punktdaten komplexer wird es wenn mit kategoriealen räumlichen Refrenzdaten vergliehcen wird. 

Der hiefür gebräuchlichste Ansatz ist eine Fehlermatrix oder Konfusionstabelle. Die Vor allem die Kappa-Koeffizienten sind üblicherweise die grundlegenden Kennzahlen der Genauigkeitsbewertung.

### Berechnung einer Konfusionmatrix

Die Berechnung vom Qualitätsmassen basiert auf einer Kreuztabelle von zwei Karten. Dabei ist die eine Karte in in Zeilen und die andere in Spalten angeordnet. Die Zeilensummen zeigen den Anteil der Pixel für jede Klasse in Karte A, die Spaltensummen für Karte B. Die Tabelle gibt an, wie viel % der Pixel in beiden Karten übereinstimmen (Diagonale) sowie wie viel % der Pixel in jeder Klasse nicht übereinstimmen. 

```{r Fehlermatrix}

## ---- Change Detection Auswertung ----

# Differenzbild random forest
tmap_mode("view")
tmap::qtm(prediction_rf_2020 - prediction_rf_2019,title = "kmeans 2019")

# ---- CDA Extraktion der Klassennamen ----
categories = levels(prediction_rf_2019)[[1]]$value
categories

# ---- Berechnung der Konfusions Matrix Tabelle mit derraster Paket Basisfunktion ----
ct = raster::crosstab(prediction_rf_2019,prediction_mlc_2019$map)
rownames(ct) = categories
colnames(ct) = categories
ct %>%
  kbl(caption = "Crosstab rf 2019 vs mlc 2019") %>%
  kable_classic(full_width = F)

```




### Veränderungs Raster aus der Konfusionsmatrix

Räumlich visualsiert werden können die die Daten mit nachfolgendem Skript. 

```{r cross_raster}

# Erzeugen aller Vergleichsraster der Kontingenztabelle
# Die lapply funktionen sind integrierte FOR Schleifen die über die Liste der
# Kategorien die Funktion changefrom() für die Kreuztabelle anwenden
r = lapply(1:length(categories),
           function(i){lapply(1:length(categories),
                              function(j){changefrom(prediction_rf_2019, prediction_rf_2020, i,j)})})
r

# ---- Visualsierung der Kreuztabellierten Von-Zu-Raster ----
# Plotten der Raster hierzu werden erneut alle Kategorien einzeln geplottet i
# und j sind hilfsvariablen um die korrekten Raster Layer ansprechen zu können.
# t ist eine Hilfvariable um eine Liste für die Ergebnisbilder hochzählen zu
# können
tmap_mode("view")
t=i=j=1 # setze zählvariablen auf 1
m=list() # erzeuge leere Liste für die Karten
for(cat1 in categories)  { # für jede Kategorie
  for(cat2 in categories)  { # mit jeder Kategorie
    # plotte die Karte
    m[[t]]  = tm_shape(st_as_stars(r[[i]][[j]])) +
      tm_raster(col = "layer",palette = "viridis",style = "cat",
                title = if(cat1==cat2) {
                  paste("no changes " , unique(cat1,cat2))
                }
                else if (cat1!=cat2) {
                  paste(cat1," -> ",cat2)
                })
    # zähle die innere schleife hoch
    j = j + 1
    # zähle die ergebnisliste hoch
    t = t + 1
  }
  # innere schleife abgearbeitet setze sie auf  den Anfang zurück
  j = 1
  # zähle die äußere Schleife hoch
  i = i + 1
}
# Interaktive und synchronisierte Karten
tmap::tmap_arrange(m,sync = TRUE)
```


### Berechung der Kappa Indizes

Vor allem in der Fernerkundung und der räumlichen Analyse kategorialer Daten ist [@cohen1960] ein beliebtes Maß eine Klassifizierung (Vorhersage) mit einer Karte Referenzkarten (Beobachtung/andersartige Beobachtung) zu vergleichen. Allgemeiner ausgedrückt, zwei kategoriale Datensätzen miteinander zu vergleichen. Cohen's Kappa Index vergleicht den Anteil übereinstimmender Pixel zweier Raster mit der erwarteten Übereinstimmung bei zufälliger Pixelanordnung. Die Indexwerte liegen zwischen -1 und 1 wobei ein Indexwert von 0 einem Ergebnis entspricht, das bei zufälliger Pixelanordnung erwartet werden kann. Ein Indexwert von 1 bedeutet genaue Übereinstimmung. Auch wenn die Interpretation der Werte von der Fragestellung abhängt bieten [@Landis&Koch1977] und [Monserud&Leemans1992] eine Orientierung zur Interpretation.



```{r Kreuztabelle }
tibble(
  'Kategorie' =     c("Kategorie A","Kategorie B","Summe"),
  'Kategorie A' = c("$$p_{(1/1)}$$","$$p_{(2/1)}$$","$$pT_A= \\sum_{i=1}^2 p_{1,i}$$"),
  'Kategorie B' = c("$$p_{(1/2)}$$","$$p_{(2/2)}$$","$$pT_B= \\sum_{i=1}^2 p_{1,i}$$"),
  'Summe' = c("$$Tp_A= \\sum_{i=1}^2 p_{1,i}$$","$$Tp_B= \\sum_{i=1}^2 p_{1,i}$$","$$1$$"),
) %>%
  kbl(caption = "Kreuztabelle") %>% 
  kable_classic(full_width = T) %>% 
  kable_styling(bootstrap_options = c("striped", "hover"))
```

Aus der Kreuztabelle werden PA (Anteil an Übereinstimmung), PE (erwarteter Anteil an Übereinstimmung) und Pmax (maximal erreichbarer Anteil an Übereinstimmung) berechnet:

$PA= \sum_{i=1}^2 p_{i,i}$

$PE= \sum_{i=1}^2 pT_i*Tp_i$

$Pmax= \sum_{i=1}^2 min(pT_i,Tp_i)$

Der Kappaindex K lässt sich in Khisto und Klocation aufteilen [@Pontius2000],[@Hagen2002] und ist das Produkt aus beiden, ergibt sich also aus der quantitativen Ähnlichkeit und der Ähnlichkeit im Bezug auf die Lage der Kategorien. Khisto gibt die quantitative Ähnlichkeit von 2 Karten an und ergibt sich aus dem Histogramm der einzelnen Kategorien. Der Index sagt aus wie gut die Verteilung der Pixel auf die einzelnen Kategorien übereinstimmt. Klocation gibt die Ähnlichkeit der räumlichen Lage der Kategorien an. Die Ähnlichkeit der Karten wird skaliert auf die maximal erreichbare Ähnlichkeit entsprechend der gegebenen Pixelzahlen der Kategorien. D.h. Klocation ist der Kappaindex der erreicht werden könnte wenn Khisto 1 wäre, also die Pixelzahlen der Klassen übereinstimmen.

$K=\frac{PA-PE}{1-PE}=K_{histo}*K_{location}$
$K_{histo}=\frac{Pmax-PE}{1-PE}$

$K_{location}=\frac{PA-PE}{Pmax-PE}$


### Mengenabweichung (quantity disagreement) und Zuordnungsabweichung (allocation disagreement)

Jedoch schlagen (@Pontius_Milliones2011) als optimale Vorgehensweise vor aus der Kreuztabellenmatrix die Parameter *Mengenabweichung* und *Zuordnungsabweichung* zu berechnen Tatsächlich ermöglichen diese Parameter eine gute Einschätzung der Mengen- und Lagequalität der Übereinstimmung kategorialer Daten.

Die Abweichungen können wie folgt berechnet werden.

$allocation \ disagreement=100*(Pmax-PA)$

$quantity \ disagreement=100*(1-Pmax)$

```{r Kappa-2019}
# ---- kappa ----
# Vergleich der Übereinstimmung unterschiedlicher Klassifikationen (hier MaxLike
# und RF) mit Hilfe diverser Kappa Werte
# https://giswerk.org/doku.php?id=r:r-tutorials:calculatekappa
# 2019
kstat(prediction_mlc_2019$map,prediction_rf_2019, perCategory = FALSE)[,c(1:3,7:8)]  %>%
  kbl(caption = "Kappa 2019 MLC vs RF") %>%
  kable_classic(full_width = F)  %>%
  column_spec(1,tooltip = "More Information",color = "red", link = "https://giswerk.org/doku.php?id=r:r-tutorials:calculatekappa")
```

```{r Kappa-2020}
# 2020
kstat(prediction_mlc_2020$map,prediction_rf_2020,perCategory = FALSE)[,c(1:3,7:8)]  %>%
  kbl(caption = "Kappa 2020 MLC vs RF") %>%
  kable_classic(full_width = F) %>%
  column_spec(1,tooltip = "More Information",color = "red", link = "https://giswerk.org/doku.php?id=r:r-tutorials:calculatekappa")
```



### Räumliche Analyse der Veränderungen mit dem Paket `motif`

### Analyse der räumlich aggregierten  Veränderungswahrscheinlichkeit 

```{r motif1}

# ---- Analyse von Veränderungen mit dem paket motif ----
# lsp_compare vergleicht zwei (oder mehr) kategoriale Karten (change detection
# klassifikationen etc.) miteinander und nutzt für die Ausgabe der
# Wahrscheinlichkeiten verschiedener räumlicher Aggregierungsstufen und
# Merkmalsraum-Distanzen um Veränderungswahrscheinlichkeiten zu ermitteln
mrf_compare_2020_2019 = lsp_compare(st_as_stars(mask*prediction_rf_2019),
                                    st_as_stars(mask*prediction_rf_2020),
                                    type = "cove",
                                    dist_fun = "jensen-shannon",
                                    window = win_size,
                                    threshold = 0.9)

# Visualisierung der Gesamtwahrscheinlichkeiten Achtung logarithmische Skala

tmap_mode("view")
tm_compare2 = tm_shape(mrf_compare_2020_2019) +
  tm_raster("dist",
            breaks = c(0, 0.001, 0.01, 0.1, 1.01),
            legend.is.portrait = F,
            palette = "viridis",
            title =  "Distance (JSD)") +
  tm_layout(legend.show = TRUE,
            legend.text.size = 0.3,
            legend.outside = TRUE) +
  tm_legend(scale= 0.5,
            legend.outside=T,
            title = paste("RF 2019 vs 2020 ",win_size*10,"m**2" ),
            title.size = 1.0) +
  tm_grid()

tm_compare2
```


### Identifikation der Gebiete maximaler  Veränderungen 

```{r motif2}
# ---- Detail-Analyse Teil 1 ----
# Identifikation der Gebiete (Referenz ist win_size) die maximale Veränderungen
# aufweisen im Beispiel soll  "dist" soll größer 0.001 sein (logarithmische
# Skalierung!)
lc_am_compare_sel = st_as_sf(mrf_compare_2020_2019) %>%
  subset(dist > 0.01)

# Sortierung nach Größe
lc_am_compare_sel = lc_am_compare_sel[order(lc_am_compare_sel$dist,decreasing = TRUE), ]
lc_am_compare_sel

##- Visualsierung
# Plotten der top ten gebiete wir nutzen die selbst geschriebene Funktion tm_plot()
# siehe src/functions/fun_tmap.R
#tm_plot(sel=lc_am_compare_sel[1:nrow(lc_am_compare_sel),],ov = T)
# als interaktive karte
tm_plot(sel=lc_am_compare_sel[1:nrow(lc_am_compare_sel),],vt = "plot",ov = T)

```


### Visulisierung der Top Veränderungs-Superpixel

```{r motif3}

# ---- Visualsierng Detail-Analyse ----
# Extraktion nach der sortierten Liste lc_comapare_sel  werden die top 10 change
# detection hotspots Daten extrahiert und in die liste lc geschrieben
lc = lapply(seq(1:10),function(i){
              lsp_extract(c(st_as_stars(prediction_rf_2019),
                            st_as_stars(prediction_rf_2020)),
                          window = win_size,
                          id = lc_am_compare_sel$id[i])
            })

# Erzeugen der top 3 Change Detection Hotspots Karten-Ausschnitte
tm_lc = lapply(seq(1:3),function(i){
               tm_plot(lc[[i]],vt = "view",ov = T)
             })

# plotten der erzeugten Karten
tmap_arrange(tm_lc)

# Erzeugen der top 3 Change Detection Hotspots Karten-Ausschnitte
tm_lc = lapply(seq(1:3),function(i){
               tm_plot(lc[[i]],vt = "plot",ov = T)
             })

# plotten der erzeugten Karten
tmap_arrange(tm_lc)

#####

```
# References